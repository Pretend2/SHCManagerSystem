{"ast":null,"code":"import tzTokenizeDate from '../tzTokenizeDate/index.js';\nimport newDateUTC from '../newDateUTC/index.js';\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-]\\d{2}):?(\\d{2})$/\n}; // Parse various time zone offset formats to an offset in milliseconds\n\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset; // Empty string\n\n  if (timezoneString === '') {\n    return 0;\n  } // Z\n\n\n  token = patterns.timezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  }\n\n  var hours; // ±hh\n\n  token = patterns.timezoneHH.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n\n    return -(hours * MILLISECONDS_IN_HOUR);\n  } // ±hh:mm or ±hhmm\n\n\n  token = patterns.timezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n    var minutes = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return hours > 0 ? -absoluteOffset : absoluteOffset;\n  } // IANA time zone\n\n\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n\n  return NaN;\n}\n\nfunction toUtcDate(date) {\n  return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString); // ms dropped because it's not provided by tzTokenizeDate\n\n  var asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess\n\n  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts\n\n  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change, and we're done\n\n  if (offset === o2) {\n    return offset;\n  } // If not, change the ts by the difference in the offset\n\n\n  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done\n\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n\n  if (o2 === o3) {\n    return o2;\n  } // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n\n\n  return Math.max(o2, o3);\n}\n\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);\n}\n\nvar validIANATimezoneCache = {};\n\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true;\n\n  try {\n    new Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    validIANATimezoneCache[timeZoneString] = true;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}","map":{"version":3,"names":["tzTokenizeDate","newDateUTC","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","tzParseTimezone","timezoneString","date","isUtcDate","token","absoluteOffset","exec","hours","parseInt","validateTimezone","NaN","minutes","Math","abs","isValidTimezoneIANAString","Date","now","utcDate","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tokens","asUTC","getTime","asTS","over","localTS","utcGuess","o2","o3","max","validIANATimezoneCache","timeZoneString","Intl","DateTimeFormat","undefined","timeZone","error"],"sources":["E:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js"],"sourcesContent":["import tzTokenizeDate from '../tzTokenizeDate/index.js'\nimport newDateUTC from '../newDateUTC/index.js'\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\n\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-]\\d{2}):?(\\d{2})$/,\n}\n\n// Parse various time zone offset formats to an offset in milliseconds\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token\n  var absoluteOffset\n\n  // Empty string\n  if (timezoneString === '') {\n    return 0\n  }\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  var hours\n\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n\n    if (!validateTimezone(hours)) {\n      return NaN\n    }\n\n    return -(hours * MILLISECONDS_IN_HOUR)\n  }\n\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    var minutes = parseInt(token[2], 10)\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN\n    }\n\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n    return hours > 0 ? -absoluteOffset : absoluteOffset\n  }\n\n  // IANA time zone\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now())\n    var utcDate = isUtcDate ? date : toUtcDate(date)\n\n    var offset = calcOffset(utcDate, timezoneString)\n\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString)\n\n    return -fixedOffset\n  }\n\n  return NaN\n}\n\nfunction toUtcDate(date) {\n  return newDateUTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n    date.getSeconds(),\n    date.getMilliseconds()\n  )\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString)\n\n  // ms dropped because it's not provided by tzTokenizeDate\n  var asUTC = newDateUTC(\n    tokens[0],\n    tokens[1] - 1,\n    tokens[2],\n    tokens[3] % 24,\n    tokens[4],\n    tokens[5],\n    0\n  ).getTime()\n\n  var asTS = date.getTime()\n  var over = asTS % 1000\n  asTS -= over >= 0 ? over : 1000 + over\n  return asUTC - asTS\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime()\n\n  // Our UTC time is just a guess because our offset is just a guess\n  var utcGuess = localTS - offset\n\n  // Test whether the zone matches the offset for this ts\n  var o2 = calcOffset(new Date(utcGuess), timezoneString)\n\n  // If so, offset didn't change, and we're done\n  if (offset === o2) {\n    return offset\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset\n\n  // If that gives us the local time we want, we're done\n  var o3 = calcOffset(new Date(utcGuess), timezoneString)\n  if (o2 === o3) {\n    return o2\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n  return Math.max(o2, o3)\n}\n\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59))\n}\n\nvar validIANATimezoneCache = {}\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true\n  try {\n    new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString })\n    validIANATimezoneCache[timeZoneString] = true\n    return true\n  } catch (error) {\n    return false\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}