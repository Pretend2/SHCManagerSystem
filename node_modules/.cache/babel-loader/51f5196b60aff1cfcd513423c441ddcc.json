{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from './utils';\nimport { provideCarouselContext } from './CarouselContext';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem, { isCarouselItem } from './CarouselItem';\nimport style from './styles/index.cssr';\nconst transitionProperties = ['transitionDuration', 'transitionTimingFunction'];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), {\n  defaultIndex: {\n    type: Number,\n    default: 0\n  },\n  currentIndex: Number,\n  showArrow: Boolean,\n  dotType: {\n    type: String,\n    default: 'dot'\n  },\n  dotPlacement: {\n    type: String,\n    default: 'bottom'\n  },\n  slidesPerView: {\n    type: [Number, String],\n    default: 1\n  },\n  spaceBetween: {\n    type: Number,\n    default: 0\n  },\n  centeredSlides: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  autoplay: Boolean,\n  interval: {\n    type: Number,\n    default: 5000\n  },\n  loop: {\n    type: Boolean,\n    default: true\n  },\n  effect: {\n    type: String,\n    default: 'slide'\n  },\n  showDots: {\n    type: Boolean,\n    default: true\n  },\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  transitionStyle: {\n    type: Object,\n    default: () => ({\n      transitionDuration: '300ms'\n    })\n  },\n  transitionProps: Object,\n  draggable: Boolean,\n  prevSlideStyle: [Object, String],\n  nextSlideStyle: [Object, String],\n  touchable: {\n    type: Boolean,\n    default: true\n  },\n  mousewheel: Boolean,\n  keyboard: Boolean,\n  'onUpdate:currentIndex': Function,\n  onUpdateCurrentIndex: Function\n}); // only one carousel is allowed to trigger touch globally\n\nlet globalDragging = false;\nexport default defineComponent({\n  name: 'Carousel',\n  props: carouselProps,\n\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props); // Dom\n\n    const selfElRef = ref(null);\n    const slidesElRef = ref(null);\n    const slideElsRef = ref([]);\n    const slideVNodesRef = {\n      value: []\n    }; // Computed states\n\n    const verticalRef = computed(() => props.direction === 'vertical');\n    const sizeAxisRef = computed(() => verticalRef.value ? 'height' : 'width');\n    const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n    const sequenceLayoutRef = computed(() => props.effect === 'slide');\n    const duplicatedableRef = computed( // duplicate the copy operation in `slide` mode,\n    // because only its DOM is sequence layout\n    () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value); // user wants to control the transition animation\n\n    const userWantsControlRef = computed(() => props.effect === 'custom'); // used to calculate total views\n\n    const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView); // used to calculate the size of each slide\n\n    const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView); // we automatically calculate total view for special slides per view\n\n    const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' || props.slidesPerView === 'auto' && props.centeredSlides); // Carousel size\n\n    const perViewSizeRef = ref({\n      width: 0,\n      height: 0\n    });\n    const slideSizesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const {\n        value: autoSlideSize\n      } = autoSlideSizeRef;\n\n      if (autoSlideSize) {\n        return slidesEls.map(slide => calculateSize(slide));\n      }\n\n      const {\n        value: slidesPerView\n      } = realSlidesPerViewRef;\n      const {\n        value: perViewSize\n      } = perViewSizeRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      let axisSize = perViewSize[axis];\n\n      if (slidesPerView !== 'auto') {\n        const {\n          spaceBetween\n        } = props;\n        const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n        const percentage = 1 / Math.max(1, slidesPerView);\n        axisSize = remaining * percentage;\n      }\n\n      const slideSize = Object.assign(Object.assign({}, perViewSize), {\n        [axis]: axisSize\n      });\n      return slidesEls.map(() => slideSize);\n    }); // The translate required to reach each slide\n\n    const slideTranlatesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      if (!slideSizes.length) return [];\n      const {\n        centeredSlides,\n        spaceBetween\n      } = props;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        [axis]: perViewSize\n      } = perViewSizeRef.value;\n      let previousTranslate = 0;\n      return slideSizes.map(({\n        [axis]: slideSize\n      }) => {\n        let translate = previousTranslate;\n\n        if (centeredSlides) {\n          translate += (slideSize - perViewSize) / 2;\n        }\n\n        previousTranslate += slideSize + spaceBetween;\n        return translate;\n      });\n    }); // Styles\n\n    const isMountedRef = ref(false);\n    const transitionStyleRef = computed(() => {\n      const {\n        transitionStyle\n      } = props;\n      return transitionStyle ? keep(transitionStyle, transitionProperties) : {};\n    });\n    const speedRef = computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));\n    const slideStylesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n\n      const getSlideSize = index => {\n        if (useComputedSize) {\n          const {\n            value: axis\n          } = sizeAxisRef;\n          return {\n            [axis]: `${slideSizesRef.value[index][axis]}px`\n          };\n        }\n      };\n\n      if (userWantsControlRef.value) {\n        // We center each slide when user wants to control the transition animation,\n        // so there is no need to calculate the offset\n        return slidesEls.map((_, i) => getSlideSize(i));\n      }\n\n      const {\n        effect,\n        spaceBetween\n      } = props;\n      const {\n        value: spaceAxis\n      } = spaceAxisRef;\n      return slidesEls.reduce((styles, _, i) => {\n        const style = Object.assign(Object.assign({}, getSlideSize(i)), {\n          [`margin-${spaceAxis}`]: `${spaceBetween}px`\n        });\n        styles.push(style);\n\n        if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n          Object.assign(style, transitionStyleRef.value);\n        }\n\n        return styles;\n      }, []);\n    }); // Total\n\n    const totalViewRef = computed(() => {\n      const {\n        value: slidesPerView\n      } = displaySlidesPerViewRef;\n      const {\n        length: totalSlides\n      } = slideElsRef.value;\n\n      if (slidesPerView !== 'auto') {\n        return Math.max(totalSlides - slidesPerView, 0) + 1;\n      } else {\n        const {\n          value: slideSizes\n        } = slideSizesRef;\n        const {\n          length\n        } = slideSizes;\n        if (!length) return totalSlides;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n        let i = length;\n\n        while (i > 1 && lastViewSize < perViewSize) {\n          i--;\n          lastViewSize += translates[i] - translates[i - 1];\n        }\n\n        return clampValue(i + 1, 1, length);\n      }\n    });\n    const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value)); // Index\n\n    const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n    const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n    const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n    const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value)); // Reality methods\n\n    function toRealIndex(index) {\n      var _a, _b;\n\n      index = clampValue(index, 0, totalViewRef.value - 1);\n      const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n      const {\n        value: lastDisplayIndex\n      } = mergedDisplayIndexRef;\n\n      if (displayIndex !== mergedDisplayIndexRef.value) {\n        uncontrolledDisplayIndexRef.value = displayIndex;\n        (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n        (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n      }\n    }\n\n    function getRealPrevIndex(index = realIndexRef.value) {\n      return getPrevIndex(index, totalViewRef.value, props.loop);\n    }\n\n    function getRealNextIndex(index = realIndexRef.value) {\n      return getNextIndex(index, totalViewRef.value, props.loop);\n    }\n\n    function isRealPrev(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealPrevIndex() === index;\n    }\n\n    function isRealNext(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealNextIndex() === index;\n    }\n\n    function isRealActive(slideOrIndex) {\n      return realIndexRef.value === getSlideIndex(slideOrIndex);\n    } // Display methods\n    // They are used to deal with the actual values displayed on the UI\n\n\n    function isDisplayActive(index) {\n      return mergedDisplayIndexRef.value === index;\n    }\n\n    function isPrevDisabled() {\n      return getRealPrevIndex() === null;\n    }\n\n    function isNextDisabled() {\n      return getRealNextIndex() === null;\n    } // To\n\n\n    function to(index) {\n      const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n\n      if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {\n        toRealIndex(realIndex);\n      }\n    }\n\n    function prev() {\n      const prevIndex = getRealPrevIndex();\n      if (prevIndex !== null) toRealIndex(prevIndex);\n    }\n\n    function next() {\n      const nextIndex = getRealNextIndex();\n      if (nextIndex !== null) toRealIndex(nextIndex);\n    }\n\n    function prevIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) prev();\n    }\n\n    function nextIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) next();\n    } // Translate to\n\n\n    let inTransition = false; // record the translate of each slide, so that it can be restored at touch\n\n    let previousTranslate = 0;\n    const translateStyleRef = ref({});\n\n    function updateTranslate(translate, speed = 0) {\n      translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n        transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,\n        transitionDuration: `${speed}ms`\n      });\n    }\n\n    function fixTranslate(speed = 0) {\n      if (sequenceLayoutRef.value) {\n        translateTo(realIndexRef.value, speed);\n      } else if (previousTranslate !== 0) {\n        if (!inTransition && speed > 0) {\n          inTransition = true;\n        }\n\n        updateTranslate(previousTranslate = 0, speed);\n      }\n    }\n\n    function translateTo(index, speed) {\n      const translate = getTranslate(index);\n\n      if (translate !== previousTranslate && speed > 0) {\n        inTransition = true;\n      }\n\n      previousTranslate = getTranslate(realIndexRef.value);\n      updateTranslate(translate, speed);\n    }\n\n    function getTranslate(index) {\n      let translate; // Deal with auto slides pre view\n\n      if (index >= totalViewRef.value - 1) {\n        translate = getLastViewTranslate();\n      } else {\n        translate = slideTranlatesRef.value[index] || 0;\n      }\n\n      return translate;\n    }\n\n    function getLastViewTranslate() {\n      if (displaySlidesPerViewRef.value === 'auto') {\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const {\n          [axis]: perViewSize\n        } = perViewSizeRef.value;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const lastTranslate = translates[translates.length - 1];\n        let overallSize;\n\n        if (lastTranslate === undefined) {\n          overallSize = perViewSize;\n        } else {\n          const {\n            value: slideSizes\n          } = slideSizesRef;\n          overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n        } // Bring the last slide to the edge\n\n\n        return overallSize - perViewSize;\n      } else {\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        return translates[totalViewRef.value - 1] || 0;\n      }\n    } // Provide\n\n\n    const carouselContext = {\n      currentIndexRef: mergedDisplayIndexRef,\n      to,\n      prev: prevIfSlideTransitionEnd,\n      next: nextIfSlideTransitionEnd,\n      isVertical: () => verticalRef.value,\n      isHorizontal: () => !verticalRef.value,\n      isPrev: isRealPrev,\n      isNext: isRealNext,\n      isActive: isRealActive,\n      isPrevDisabled,\n      isNextDisabled,\n      getSlideIndex,\n      getSlideStyle,\n      addSlide,\n      removeSlide,\n      onCarouselItemClick\n    };\n    provideCarouselContext(carouselContext);\n\n    function addSlide(slide) {\n      if (!slide) return;\n      slideElsRef.value.push(slide);\n    }\n\n    function removeSlide(slide) {\n      if (!slide) return;\n      const index = getSlideIndex(slide);\n\n      if (index !== -1) {\n        slideElsRef.value.splice(index, 1);\n      }\n    }\n\n    function getSlideIndex(slideOrIndex) {\n      return typeof slideOrIndex === 'number' ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;\n    }\n\n    function getSlideStyle(slide) {\n      const index = getSlideIndex(slide);\n\n      if (index !== -1) {\n        const styles = [slideStylesRef.value[index]];\n        const isPrev = carouselContext.isPrev(index);\n        const isNext = carouselContext.isNext(index);\n\n        if (isPrev) {\n          styles.push(props.prevSlideStyle || '');\n        }\n\n        if (isNext) {\n          styles.push(props.nextSlideStyle || '');\n        }\n\n        return normalizeStyle(styles);\n      }\n    }\n\n    function onCarouselItemClick(index, event) {\n      let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n\n      if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n        to(index);\n        allowClick = false;\n      }\n\n      if (!allowClick) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    } // Autoplay\n\n\n    let autoplayTimer = null;\n\n    function stopAutoplay() {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer);\n        autoplayTimer = null;\n      }\n    }\n\n    function resetAutoplay() {\n      stopAutoplay();\n      const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n\n      if (!disabled) {\n        autoplayTimer = window.setInterval(next, props.interval);\n      }\n    } // Drag\n\n\n    let dragStartX = 0;\n    let dragStartY = 0;\n    let dragOffset = 0;\n    let dragStartTime = 0;\n    let dragging = false;\n    let isEffectiveDrag = false;\n\n    function handleTouchstart(event) {\n      var _a;\n\n      if (globalDragging) return;\n\n      if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n        return;\n      }\n\n      globalDragging = true;\n      dragging = true;\n      isEffectiveDrag = false;\n      dragStartTime = Date.now();\n      stopAutoplay();\n\n      if (event.type !== 'touchstart' && !event.target.isContentEditable) {\n        event.preventDefault();\n      }\n\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n\n      if (verticalRef.value) {\n        dragStartY = touchEvent.clientY;\n      } else {\n        dragStartX = touchEvent.clientX;\n      }\n\n      if (props.touchable) {\n        on('touchmove', document, handleTouchmove, {\n          passive: true\n        });\n        on('touchend', document, handleTouchend);\n        on('touchcancel', document, handleTouchend);\n      }\n\n      if (props.draggable) {\n        on('mousemove', document, handleTouchmove);\n        on('mouseup', document, handleTouchend);\n      }\n    }\n\n    function handleTouchmove(event) {\n      const {\n        value: vertical\n      } = verticalRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;\n      const perViewSize = perViewSizeRef.value[axis];\n      dragOffset = clampValue(offset, -perViewSize, perViewSize);\n\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (sequenceLayoutRef.value) {\n        updateTranslate(previousTranslate - dragOffset, 0);\n      }\n    }\n\n    function handleTouchend() {\n      const {\n        value: realIndex\n      } = realIndexRef;\n      let currentIndex = realIndex;\n\n      if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n        const currentTranslate = previousTranslate - dragOffset;\n        const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];\n        let prevOffset = null;\n\n        for (let i = 0; i < translates.length; i++) {\n          const offset = Math.abs(translates[i] - currentTranslate);\n\n          if (prevOffset !== null && prevOffset < offset) {\n            break;\n          }\n\n          prevOffset = offset;\n          currentIndex = i;\n        }\n      }\n\n      if (currentIndex === realIndex) {\n        const timeElapsed = Date.now() - dragStartTime;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis]; // more than 50% width or faster than 0.4px per ms\n\n        if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n          currentIndex = getRealPrevIndex(realIndex);\n        } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {\n          currentIndex = getRealNextIndex(realIndex);\n        }\n      }\n\n      if (currentIndex !== null && currentIndex !== realIndex) {\n        isEffectiveDrag = true;\n        toRealIndex(currentIndex);\n        void nextTick(() => {\n          if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n            fixTranslate(speedRef.value);\n          }\n        });\n      } else {\n        fixTranslate(speedRef.value);\n      }\n\n      resetDragStatus();\n      resetAutoplay();\n    }\n\n    function resetDragStatus() {\n      if (dragging) {\n        globalDragging = false;\n      }\n\n      dragging = false;\n      dragStartX = 0;\n      dragStartY = 0;\n      dragOffset = 0;\n      dragStartTime = 0;\n      off('touchmove', document, handleTouchmove);\n      off('touchend', document, handleTouchend);\n      off('touchcancel', document, handleTouchend);\n      off('mousemove', document, handleTouchmove);\n      off('mouseup', document, handleTouchend);\n    }\n\n    function handleTransitionEnd() {\n      if (sequenceLayoutRef.value && inTransition) {\n        const {\n          value: realIndex\n        } = realIndexRef;\n        translateTo(realIndex, 0);\n      } else {\n        resetAutoplay();\n      }\n\n      if (sequenceLayoutRef.value) {\n        translateStyleRef.value.transitionDuration = '0ms';\n      }\n\n      inTransition = false;\n    }\n\n    function handleMousewheel(event) {\n      event.preventDefault();\n      if (inTransition) return;\n      let {\n        deltaX,\n        deltaY\n      } = event;\n\n      if (event.shiftKey && !deltaX) {\n        deltaX = deltaY;\n      }\n\n      const prevMultiplier = -1;\n      const nextMultiplier = 1;\n      const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n      let rx = 0;\n      let ry = 0;\n\n      if (verticalRef.value) {\n        ry = m;\n      } else {\n        rx = m;\n      }\n\n      const responseStep = 10;\n\n      if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n        if (m === nextMultiplier && !isNextDisabled()) {\n          next();\n        } else if (m === prevMultiplier && !isPrevDisabled()) {\n          prev();\n        }\n      }\n    }\n\n    function handleResize() {\n      perViewSizeRef.value = calculateSize(selfElRef.value, true);\n      resetAutoplay();\n    }\n\n    function handleSlideResize() {\n      var _a, _b;\n\n      if (autoSlideSizeRef.value) {\n        (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n        slideSizesRef.effect.run();\n      }\n    }\n\n    function handleMouseenter() {\n      if (props.autoplay) {\n        stopAutoplay();\n      }\n    }\n\n    function handleMouseleave() {\n      if (props.autoplay) {\n        resetAutoplay();\n      }\n    }\n\n    onMounted(() => {\n      watchEffect(resetAutoplay);\n      requestAnimationFrame(() => isMountedRef.value = true);\n    });\n    onBeforeUnmount(() => {\n      resetDragStatus();\n      stopAutoplay();\n    }); // Fix index when remounting\n\n    onUpdated(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      const {\n        value: slideVNodes\n      } = slideVNodesRef;\n      const indexMap = new Map();\n\n      const getDisplayIndex = el => // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      indexMap.has(el) ? indexMap.get(el) : -1;\n\n      let isChanged = false;\n\n      for (let i = 0; i < slidesEls.length; i++) {\n        const index = slideVNodes.findIndex(v => v.el === slidesEls[i]);\n\n        if (index !== i) {\n          isChanged = true;\n        }\n\n        indexMap.set(slidesEls[i], index);\n      }\n\n      if (isChanged) {\n        slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n      }\n    });\n    watch(realIndexRef, (realIndex, lastRealIndex) => {\n      if (realIndex === lastRealIndex) return;\n      resetAutoplay();\n\n      if (sequenceLayoutRef.value) {\n        if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n          const {\n            value: length\n          } = totalViewRef;\n\n          if (realIndex === length - 2 && lastRealIndex === 1) {\n            realIndex = 0;\n          } else if (realIndex === 1 && lastRealIndex === length - 2) {\n            realIndex = length - 1;\n          }\n        }\n\n        translateTo(realIndex, speedRef.value);\n      } else {\n        fixTranslate();\n      }\n    }, {\n      immediate: true\n    });\n    watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => toRealIndex(realIndexRef.value)));\n    watch(slideTranlatesRef, () => sequenceLayoutRef.value && fixTranslate(), {\n      deep: true\n    });\n    watch(sequenceLayoutRef, value => {\n      if (!value) {\n        inTransition = false; // if the current mode does not support translate, reset the position of the wrapper\n\n        updateTranslate(previousTranslate = 0);\n      } else {\n        fixTranslate();\n      }\n    });\n    const slidesControlListenersRef = computed(() => {\n      return {\n        onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n        onMousedown: props.draggable ? handleTouchstart : undefined,\n        onWheel: props.mousewheel ? handleMousewheel : undefined\n      };\n    });\n    const arrowSlotPropsRef = computed(() => Object.assign(Object.assign({}, keep(carouselContext, ['to', 'prev', 'next', 'isPrevDisabled', 'isNextDisabled'])), {\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value\n    }));\n    const dotSlotPropsRef = computed(() => ({\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value,\n      to: carouselContext.to\n    }));\n    const caroulseExposedMethod = {\n      getCurrentIndex: () => mergedDisplayIndexRef.value,\n      to,\n      prev,\n      next\n    };\n    const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          dotSize,\n          dotColor,\n          dotColorActive,\n          dotColorFocus,\n          dotLineWidth,\n          dotLineWidthActive,\n          arrowColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-dot-color': dotColor,\n        '--n-dot-color-focus': dotColorFocus,\n        '--n-dot-color-active': dotColorActive,\n        '--n-dot-size': dotSize,\n        '--n-dot-line-width': dotLineWidth,\n        '--n-dot-line-width-active': dotLineWidthActive,\n        '--n-arrow-color': arrowColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('carousel', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      selfElRef,\n      slidesElRef,\n      slideVNodes: slideVNodesRef,\n      duplicatedable: duplicatedableRef,\n      userWantsControl: userWantsControlRef,\n      autoSlideSize: autoSlideSizeRef,\n      displayIndex: mergedDisplayIndexRef,\n      realIndex: realIndexRef,\n      slideStyles: slideStylesRef,\n      translateStyle: translateStyleRef,\n      slidesControlListeners: slidesControlListenersRef,\n      handleTransitionEnd,\n      handleResize,\n      handleSlideResize,\n      handleMouseenter,\n      handleMouseleave,\n      isActive: isDisplayActive,\n      arrowSlotProps: arrowSlotPropsRef,\n      dotSlotProps: dotSlotPropsRef\n    }, caroulseExposedMethod), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n\n  render() {\n    var _a;\n\n    const {\n      mergedClsPrefix,\n      showArrow,\n      userWantsControl,\n      slideStyles,\n      dotType,\n      dotPlacement,\n      slidesControlListeners,\n      transitionProps = {},\n      arrowSlotProps,\n      dotSlotProps,\n      $slots: {\n        default: defaultSlot,\n        dots: dotsSlot,\n        arrow: arrowSlot\n      }\n    } = this;\n    const children = defaultSlot && flatten(defaultSlot()) || [];\n    let slides = filterCarouselItem(children);\n\n    if (!slides.length) {\n      slides = children.map(ch => h(NCarouselItem, null, {\n        default: () => cloneVNode(ch)\n      }));\n    }\n\n    if (this.duplicatedable) {\n      slides = addDuplicateSlides(slides);\n    }\n\n    this.slideVNodes.value = slides; // When users need to customize the size of the slide,\n    // we listen to them to fix the current translate\n\n    if (this.autoSlideSize) {\n      slides = slides.map(slide => h(VResizeObserver, {\n        onResize: this.handleSlideResize\n      }, {\n        default: () => slide\n      }));\n    }\n\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    return h(\"div\", Object.assign({\n      ref: \"selfElRef\",\n      class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === 'vertical' && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],\n      style: this.cssVars\n    }, slidesControlListeners, {\n      onMouseenter: this.handleMouseenter,\n      onMouseleave: this.handleMouseleave\n    }), h(VResizeObserver, {\n      onResize: this.handleResize\n    }, {\n      default: () => h(\"div\", {\n        ref: \"slidesElRef\",\n        class: `${mergedClsPrefix}-carousel__slides`,\n        role: \"listbox\",\n        style: this.translateStyle,\n        onTransitionend: this.handleTransitionEnd\n      }, userWantsControl ? slides.map((slide, i) => h(\"div\", {\n        style: slideStyles[i],\n        key: i\n      }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n        default: () => slide\n      }), [[vShow, this.isActive(i)]]))) : slides)\n    }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [h(NCarouselDots, {\n      key: dotType + dotPlacement,\n      total: dotSlotProps.total,\n      currentIndex: dotSlotProps.currentIndex,\n      dotType: dotType,\n      trigger: this.trigger,\n      keyboard: this.keyboard\n    })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [h(NCarouselArrow, null)]));\n  }\n\n});\n\nfunction filterCarouselItem(vnodes) {\n  return vnodes.reduce((carouselItems, vnode) => {\n    if (isCarouselItem(vnode)) {\n      carouselItems.push(vnode);\n    }\n\n    return carouselItems;\n  }, []);\n}","map":{"version":3,"names":["h","defineComponent","ref","cloneVNode","computed","onBeforeUnmount","watch","withDirectives","vShow","Transition","toRef","nextTick","onMounted","watchEffect","normalizeStyle","onUpdated","VResizeObserver","useMergedState","on","off","getPreciseEventTarget","useConfig","useTheme","useThemeClass","flatten","keep","resolveSlotWithProps","carouselLight","calculateSize","clampValue","resolveSpeed","isTouchEvent","getNextIndex","getPrevIndex","getDisplayIndex","getRealIndex","getDisplayTotalView","addDuplicateSlides","provideCarouselContext","NCarouselDots","NCarouselArrow","NCarouselItem","isCarouselItem","style","transitionProperties","carouselProps","Object","assign","props","defaultIndex","type","Number","default","currentIndex","showArrow","Boolean","dotType","String","dotPlacement","slidesPerView","spaceBetween","centeredSlides","direction","autoplay","interval","loop","effect","showDots","trigger","transitionStyle","transitionDuration","transitionProps","draggable","prevSlideStyle","nextSlideStyle","touchable","mousewheel","keyboard","Function","onUpdateCurrentIndex","globalDragging","name","setup","mergedClsPrefixRef","inlineThemeDisabled","selfElRef","slidesElRef","slideElsRef","slideVNodesRef","value","verticalRef","sizeAxisRef","spaceAxisRef","sequenceLayoutRef","duplicatedableRef","userWantsControlRef","displaySlidesPerViewRef","realSlidesPerViewRef","autoSlideSizeRef","perViewSizeRef","width","height","slideSizesRef","slidesEls","length","autoSlideSize","map","slide","perViewSize","axis","axisSize","remaining","percentage","Math","max","slideSize","slideTranlatesRef","slideSizes","previousTranslate","translate","isMountedRef","transitionStyleRef","speedRef","slideStylesRef","useComputedSize","getSlideSize","index","_","i","spaceAxis","reduce","styles","push","totalViewRef","totalSlides","translates","lastViewSize","displayTotalViewRef","defaultRealIndex","uncontrolledDisplayIndexRef","mergedDisplayIndexRef","realIndexRef","toRealIndex","_a","_b","displayIndex","lastDisplayIndex","call","getRealPrevIndex","getRealNextIndex","isRealPrev","slideOrIndex","getSlideIndex","isRealNext","isRealActive","isDisplayActive","isPrevDisabled","isNextDisabled","to","realIndex","prev","prevIndex","next","nextIndex","prevIfSlideTransitionEnd","inTransition","nextIfSlideTransitionEnd","translateStyleRef","updateTranslate","speed","transform","fixTranslate","translateTo","getTranslate","getLastViewTranslate","lastTranslate","overallSize","undefined","carouselContext","currentIndexRef","isVertical","isHorizontal","isPrev","isNext","isActive","getSlideStyle","addSlide","removeSlide","onCarouselItemClick","splice","indexOf","event","allowClick","dragging","isEffectiveDrag","preventDefault","stopPropagation","autoplayTimer","stopAutoplay","clearInterval","resetAutoplay","disabled","window","setInterval","dragStartX","dragStartY","dragOffset","dragStartTime","handleTouchstart","contains","Date","now","target","isContentEditable","touchEvent","touches","clientY","clientX","document","handleTouchmove","passive","handleTouchend","vertical","offset","cancelable","currentTranslate","slice","prevOffset","abs","timeElapsed","resetDragStatus","handleTransitionEnd","handleMousewheel","deltaX","deltaY","shiftKey","prevMultiplier","nextMultiplier","m","rx","ry","responseStep","handleResize","handleSlideResize","scheduler","run","handleMouseenter","handleMouseleave","requestAnimationFrame","slideVNodes","indexMap","Map","el","has","get","isChanged","findIndex","v","set","sort","a","b","lastRealIndex","immediate","deep","slidesControlListenersRef","onTouchstartPassive","onMousedown","onWheel","arrowSlotPropsRef","total","dotSlotPropsRef","caroulseExposedMethod","getCurrentIndex","themeRef","cssVarsRef","common","cubicBezierEaseInOut","self","dotSize","dotColor","dotColorActive","dotColorFocus","dotLineWidth","dotLineWidthActive","arrowColor","themeClassHandle","mergedClsPrefix","duplicatedable","userWantsControl","slideStyles","translateStyle","slidesControlListeners","arrowSlotProps","dotSlotProps","cssVars","themeClass","onRender","render","$slots","defaultSlot","dots","dotsSlot","arrow","arrowSlot","children","slides","filterCarouselItem","ch","onResize","class","onMouseenter","onMouseleave","role","onTransitionend","key","vnodes","carouselItems","vnode"],"sources":["E:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/naive-ui/es/carousel/src/Carousel.js"],"sourcesContent":["import { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from './utils';\nimport { provideCarouselContext } from './CarouselContext';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem, { isCarouselItem } from './CarouselItem';\nimport style from './styles/index.cssr';\nconst transitionProperties = [\n    'transitionDuration',\n    'transitionTimingFunction'\n];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), { defaultIndex: {\n        type: Number,\n        default: 0\n    }, currentIndex: Number, showArrow: Boolean, dotType: {\n        type: String,\n        default: 'dot'\n    }, dotPlacement: {\n        type: String,\n        default: 'bottom'\n    }, slidesPerView: {\n        type: [Number, String],\n        default: 1\n    }, spaceBetween: {\n        type: Number,\n        default: 0\n    }, centeredSlides: Boolean, direction: {\n        type: String,\n        default: 'horizontal'\n    }, autoplay: Boolean, interval: {\n        type: Number,\n        default: 5000\n    }, loop: {\n        type: Boolean,\n        default: true\n    }, effect: {\n        type: String,\n        default: 'slide'\n    }, showDots: {\n        type: Boolean,\n        default: true\n    }, trigger: {\n        type: String,\n        default: 'click'\n    }, transitionStyle: {\n        type: Object,\n        default: () => ({\n            transitionDuration: '300ms'\n        })\n    }, transitionProps: Object, draggable: Boolean, prevSlideStyle: [Object, String], nextSlideStyle: [Object, String], touchable: {\n        type: Boolean,\n        default: true\n    }, mousewheel: Boolean, keyboard: Boolean, 'onUpdate:currentIndex': Function, onUpdateCurrentIndex: Function });\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n    name: 'Carousel',\n    props: carouselProps,\n    setup(props) {\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        // Dom\n        const selfElRef = ref(null);\n        const slidesElRef = ref(null);\n        const slideElsRef = ref([]);\n        const slideVNodesRef = { value: [] };\n        // Computed states\n        const verticalRef = computed(() => props.direction === 'vertical');\n        const sizeAxisRef = computed(() => (verticalRef.value ? 'height' : 'width'));\n        const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n        const sequenceLayoutRef = computed(() => props.effect === 'slide');\n        const duplicatedableRef = computed(\n        // duplicate the copy operation in `slide` mode,\n        // because only its DOM is sequence layout\n        () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);\n        // user wants to control the transition animation\n        const userWantsControlRef = computed(() => props.effect === 'custom');\n        // used to calculate total views\n        const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);\n        // used to calculate the size of each slide\n        const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n        // we automatically calculate total view for special slides per view\n        const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' ||\n            (props.slidesPerView === 'auto' && props.centeredSlides));\n        // Carousel size\n        const perViewSizeRef = ref({ width: 0, height: 0 });\n        const slideSizesRef = computed(() => {\n            const { value: slidesEls } = slideElsRef;\n            if (!slidesEls.length)\n                return [];\n            const { value: autoSlideSize } = autoSlideSizeRef;\n            if (autoSlideSize) {\n                return slidesEls.map((slide) => calculateSize(slide));\n            }\n            const { value: slidesPerView } = realSlidesPerViewRef;\n            const { value: perViewSize } = perViewSizeRef;\n            const { value: axis } = sizeAxisRef;\n            let axisSize = perViewSize[axis];\n            if (slidesPerView !== 'auto') {\n                const { spaceBetween } = props;\n                const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n                const percentage = 1 / Math.max(1, slidesPerView);\n                axisSize = remaining * percentage;\n            }\n            const slideSize = Object.assign(Object.assign({}, perViewSize), { [axis]: axisSize });\n            return slidesEls.map(() => slideSize);\n        });\n        // The translate required to reach each slide\n        const slideTranlatesRef = computed(() => {\n            const { value: slideSizes } = slideSizesRef;\n            if (!slideSizes.length)\n                return [];\n            const { centeredSlides, spaceBetween } = props;\n            const { value: axis } = sizeAxisRef;\n            const { [axis]: perViewSize } = perViewSizeRef.value;\n            let previousTranslate = 0;\n            return slideSizes.map(({ [axis]: slideSize }) => {\n                let translate = previousTranslate;\n                if (centeredSlides) {\n                    translate += (slideSize - perViewSize) / 2;\n                }\n                previousTranslate += slideSize + spaceBetween;\n                return translate;\n            });\n        });\n        // Styles\n        const isMountedRef = ref(false);\n        const transitionStyleRef = computed(() => {\n            const { transitionStyle } = props;\n            return transitionStyle\n                ? keep(transitionStyle, transitionProperties)\n                : {};\n        });\n        const speedRef = computed(() => userWantsControlRef.value\n            ? 0\n            : resolveSpeed(transitionStyleRef.value.transitionDuration));\n        const slideStylesRef = computed(() => {\n            const { value: slidesEls } = slideElsRef;\n            if (!slidesEls.length)\n                return [];\n            const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n            const getSlideSize = (index) => {\n                if (useComputedSize) {\n                    const { value: axis } = sizeAxisRef;\n                    return {\n                        [axis]: `${slideSizesRef.value[index][axis]}px`\n                    };\n                }\n            };\n            if (userWantsControlRef.value) {\n                // We center each slide when user wants to control the transition animation,\n                // so there is no need to calculate the offset\n                return slidesEls.map((_, i) => getSlideSize(i));\n            }\n            const { effect, spaceBetween } = props;\n            const { value: spaceAxis } = spaceAxisRef;\n            return slidesEls.reduce((styles, _, i) => {\n                const style = Object.assign(Object.assign({}, getSlideSize(i)), { [`margin-${spaceAxis}`]: `${spaceBetween}px` });\n                styles.push(style);\n                if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n                    Object.assign(style, transitionStyleRef.value);\n                }\n                return styles;\n            }, []);\n        });\n        // Total\n        const totalViewRef = computed(() => {\n            const { value: slidesPerView } = displaySlidesPerViewRef;\n            const { length: totalSlides } = slideElsRef.value;\n            if (slidesPerView !== 'auto') {\n                return Math.max(totalSlides - slidesPerView, 0) + 1;\n            }\n            else {\n                const { value: slideSizes } = slideSizesRef;\n                const { length } = slideSizes;\n                if (!length)\n                    return totalSlides;\n                const { value: translates } = slideTranlatesRef;\n                const { value: axis } = sizeAxisRef;\n                const perViewSize = perViewSizeRef.value[axis];\n                let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n                let i = length;\n                while (i > 1 && lastViewSize < perViewSize) {\n                    i--;\n                    lastViewSize += translates[i] - translates[i - 1];\n                }\n                return clampValue(i + 1, 1, length);\n            }\n        });\n        const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));\n        // Index\n        const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n        const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n        const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n        const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));\n        // Reality methods\n        function toRealIndex(index) {\n            var _a, _b;\n            index = clampValue(index, 0, totalViewRef.value - 1);\n            const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n            const { value: lastDisplayIndex } = mergedDisplayIndexRef;\n            if (displayIndex !== mergedDisplayIndexRef.value) {\n                uncontrolledDisplayIndexRef.value = displayIndex;\n                (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n                (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n            }\n        }\n        function getRealPrevIndex(index = realIndexRef.value) {\n            return getPrevIndex(index, totalViewRef.value, props.loop);\n        }\n        function getRealNextIndex(index = realIndexRef.value) {\n            return getNextIndex(index, totalViewRef.value, props.loop);\n        }\n        function isRealPrev(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealPrevIndex() === index;\n        }\n        function isRealNext(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealNextIndex() === index;\n        }\n        function isRealActive(slideOrIndex) {\n            return realIndexRef.value === getSlideIndex(slideOrIndex);\n        }\n        // Display methods\n        // They are used to deal with the actual values displayed on the UI\n        function isDisplayActive(index) {\n            return mergedDisplayIndexRef.value === index;\n        }\n        function isPrevDisabled() {\n            return getRealPrevIndex() === null;\n        }\n        function isNextDisabled() {\n            return getRealNextIndex() === null;\n        }\n        // To\n        function to(index) {\n            const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n            if (index !== mergedDisplayIndexRef.value ||\n                realIndex !== realIndexRef.value) {\n                toRealIndex(realIndex);\n            }\n        }\n        function prev() {\n            const prevIndex = getRealPrevIndex();\n            if (prevIndex !== null)\n                toRealIndex(prevIndex);\n        }\n        function next() {\n            const nextIndex = getRealNextIndex();\n            if (nextIndex !== null)\n                toRealIndex(nextIndex);\n        }\n        function prevIfSlideTransitionEnd() {\n            if (!inTransition || !duplicatedableRef.value)\n                prev();\n        }\n        function nextIfSlideTransitionEnd() {\n            if (!inTransition || !duplicatedableRef.value)\n                next();\n        }\n        // Translate to\n        let inTransition = false;\n        // record the translate of each slide, so that it can be restored at touch\n        let previousTranslate = 0;\n        const translateStyleRef = ref({});\n        function updateTranslate(translate, speed = 0) {\n            translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n                transform: verticalRef.value\n                    ? `translateY(${-translate}px)`\n                    : `translateX(${-translate}px)`,\n                transitionDuration: `${speed}ms`\n            });\n        }\n        function fixTranslate(speed = 0) {\n            if (sequenceLayoutRef.value) {\n                translateTo(realIndexRef.value, speed);\n            }\n            else if (previousTranslate !== 0) {\n                if (!inTransition && speed > 0) {\n                    inTransition = true;\n                }\n                updateTranslate((previousTranslate = 0), speed);\n            }\n        }\n        function translateTo(index, speed) {\n            const translate = getTranslate(index);\n            if (translate !== previousTranslate && speed > 0) {\n                inTransition = true;\n            }\n            previousTranslate = getTranslate(realIndexRef.value);\n            updateTranslate(translate, speed);\n        }\n        function getTranslate(index) {\n            let translate;\n            // Deal with auto slides pre view\n            if (index >= totalViewRef.value - 1) {\n                translate = getLastViewTranslate();\n            }\n            else {\n                translate = slideTranlatesRef.value[index] || 0;\n            }\n            return translate;\n        }\n        function getLastViewTranslate() {\n            if (displaySlidesPerViewRef.value === 'auto') {\n                const { value: axis } = sizeAxisRef;\n                const { [axis]: perViewSize } = perViewSizeRef.value;\n                const { value: translates } = slideTranlatesRef;\n                const lastTranslate = translates[translates.length - 1];\n                let overallSize;\n                if (lastTranslate === undefined) {\n                    overallSize = perViewSize;\n                }\n                else {\n                    const { value: slideSizes } = slideSizesRef;\n                    overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n                }\n                // Bring the last slide to the edge\n                return overallSize - perViewSize;\n            }\n            else {\n                const { value: translates } = slideTranlatesRef;\n                return translates[totalViewRef.value - 1] || 0;\n            }\n        }\n        // Provide\n        const carouselContext = {\n            currentIndexRef: mergedDisplayIndexRef,\n            to,\n            prev: prevIfSlideTransitionEnd,\n            next: nextIfSlideTransitionEnd,\n            isVertical: () => verticalRef.value,\n            isHorizontal: () => !verticalRef.value,\n            isPrev: isRealPrev,\n            isNext: isRealNext,\n            isActive: isRealActive,\n            isPrevDisabled,\n            isNextDisabled,\n            getSlideIndex,\n            getSlideStyle,\n            addSlide,\n            removeSlide,\n            onCarouselItemClick\n        };\n        provideCarouselContext(carouselContext);\n        function addSlide(slide) {\n            if (!slide)\n                return;\n            slideElsRef.value.push(slide);\n        }\n        function removeSlide(slide) {\n            if (!slide)\n                return;\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                slideElsRef.value.splice(index, 1);\n            }\n        }\n        function getSlideIndex(slideOrIndex) {\n            return typeof slideOrIndex === 'number'\n                ? slideOrIndex\n                : slideOrIndex\n                    ? slideElsRef.value.indexOf(slideOrIndex)\n                    : -1;\n        }\n        function getSlideStyle(slide) {\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                const styles = [slideStylesRef.value[index]];\n                const isPrev = carouselContext.isPrev(index);\n                const isNext = carouselContext.isNext(index);\n                if (isPrev) {\n                    styles.push(props.prevSlideStyle || '');\n                }\n                if (isNext) {\n                    styles.push(props.nextSlideStyle || '');\n                }\n                return normalizeStyle(styles);\n            }\n        }\n        function onCarouselItemClick(index, event) {\n            let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n            if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n                to(index);\n                allowClick = false;\n            }\n            if (!allowClick) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        }\n        // Autoplay\n        let autoplayTimer = null;\n        function stopAutoplay() {\n            if (autoplayTimer) {\n                clearInterval(autoplayTimer);\n                autoplayTimer = null;\n            }\n        }\n        function resetAutoplay() {\n            stopAutoplay();\n            const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n            if (!disabled) {\n                autoplayTimer = window.setInterval(next, props.interval);\n            }\n        }\n        // Drag\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragOffset = 0;\n        let dragStartTime = 0;\n        let dragging = false;\n        let isEffectiveDrag = false;\n        function handleTouchstart(event) {\n            var _a;\n            if (globalDragging)\n                return;\n            if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n                return;\n            }\n            globalDragging = true;\n            dragging = true;\n            isEffectiveDrag = false;\n            dragStartTime = Date.now();\n            stopAutoplay();\n            if (event.type !== 'touchstart' &&\n                !event.target.isContentEditable) {\n                event.preventDefault();\n            }\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            if (verticalRef.value) {\n                dragStartY = touchEvent.clientY;\n            }\n            else {\n                dragStartX = touchEvent.clientX;\n            }\n            if (props.touchable) {\n                on('touchmove', document, handleTouchmove, { passive: true });\n                on('touchend', document, handleTouchend);\n                on('touchcancel', document, handleTouchend);\n            }\n            if (props.draggable) {\n                on('mousemove', document, handleTouchmove);\n                on('mouseup', document, handleTouchend);\n            }\n        }\n        function handleTouchmove(event) {\n            const { value: vertical } = verticalRef;\n            const { value: axis } = sizeAxisRef;\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            const offset = vertical\n                ? touchEvent.clientY - dragStartY\n                : touchEvent.clientX - dragStartX;\n            const perViewSize = perViewSizeRef.value[axis];\n            dragOffset = clampValue(offset, -perViewSize, perViewSize);\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            if (sequenceLayoutRef.value) {\n                updateTranslate(previousTranslate - dragOffset, 0);\n            }\n        }\n        function handleTouchend() {\n            const { value: realIndex } = realIndexRef;\n            let currentIndex = realIndex;\n            if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n                const currentTranslate = previousTranslate - dragOffset;\n                const translates = [\n                    ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),\n                    getLastViewTranslate()\n                ];\n                let prevOffset = null;\n                for (let i = 0; i < translates.length; i++) {\n                    const offset = Math.abs(translates[i] - currentTranslate);\n                    if (prevOffset !== null && prevOffset < offset) {\n                        break;\n                    }\n                    prevOffset = offset;\n                    currentIndex = i;\n                }\n            }\n            if (currentIndex === realIndex) {\n                const timeElapsed = Date.now() - dragStartTime;\n                const { value: axis } = sizeAxisRef;\n                const perViewSize = perViewSizeRef.value[axis];\n                // more than 50% width or faster than 0.4px per ms\n                if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n                    currentIndex = getRealPrevIndex(realIndex);\n                }\n                else if (dragOffset < -perViewSize / 2 ||\n                    dragOffset / timeElapsed < -0.4) {\n                    currentIndex = getRealNextIndex(realIndex);\n                }\n            }\n            if (currentIndex !== null && currentIndex !== realIndex) {\n                isEffectiveDrag = true;\n                toRealIndex(currentIndex);\n                void nextTick(() => {\n                    if (!duplicatedableRef.value ||\n                        uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n                        fixTranslate(speedRef.value);\n                    }\n                });\n            }\n            else {\n                fixTranslate(speedRef.value);\n            }\n            resetDragStatus();\n            resetAutoplay();\n        }\n        function resetDragStatus() {\n            if (dragging) {\n                globalDragging = false;\n            }\n            dragging = false;\n            dragStartX = 0;\n            dragStartY = 0;\n            dragOffset = 0;\n            dragStartTime = 0;\n            off('touchmove', document, handleTouchmove);\n            off('touchend', document, handleTouchend);\n            off('touchcancel', document, handleTouchend);\n            off('mousemove', document, handleTouchmove);\n            off('mouseup', document, handleTouchend);\n        }\n        function handleTransitionEnd() {\n            if (sequenceLayoutRef.value && inTransition) {\n                const { value: realIndex } = realIndexRef;\n                translateTo(realIndex, 0);\n            }\n            else {\n                resetAutoplay();\n            }\n            if (sequenceLayoutRef.value) {\n                translateStyleRef.value.transitionDuration = '0ms';\n            }\n            inTransition = false;\n        }\n        function handleMousewheel(event) {\n            event.preventDefault();\n            if (inTransition)\n                return;\n            let { deltaX, deltaY } = event;\n            if (event.shiftKey && !deltaX) {\n                deltaX = deltaY;\n            }\n            const prevMultiplier = -1;\n            const nextMultiplier = 1;\n            const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n            let rx = 0;\n            let ry = 0;\n            if (verticalRef.value) {\n                ry = m;\n            }\n            else {\n                rx = m;\n            }\n            const responseStep = 10;\n            if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n                if (m === nextMultiplier && !isNextDisabled()) {\n                    next();\n                }\n                else if (m === prevMultiplier && !isPrevDisabled()) {\n                    prev();\n                }\n            }\n        }\n        function handleResize() {\n            perViewSizeRef.value = calculateSize(selfElRef.value, true);\n            resetAutoplay();\n        }\n        function handleSlideResize() {\n            var _a, _b;\n            if (autoSlideSizeRef.value) {\n                (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n                slideSizesRef.effect.run();\n            }\n        }\n        function handleMouseenter() {\n            if (props.autoplay) {\n                stopAutoplay();\n            }\n        }\n        function handleMouseleave() {\n            if (props.autoplay) {\n                resetAutoplay();\n            }\n        }\n        onMounted(() => {\n            watchEffect(resetAutoplay);\n            requestAnimationFrame(() => (isMountedRef.value = true));\n        });\n        onBeforeUnmount(() => {\n            resetDragStatus();\n            stopAutoplay();\n        });\n        // Fix index when remounting\n        onUpdated(() => {\n            const { value: slidesEls } = slideElsRef;\n            const { value: slideVNodes } = slideVNodesRef;\n            const indexMap = new Map();\n            const getDisplayIndex = (el) => \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            indexMap.has(el) ? indexMap.get(el) : -1;\n            let isChanged = false;\n            for (let i = 0; i < slidesEls.length; i++) {\n                const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);\n                if (index !== i) {\n                    isChanged = true;\n                }\n                indexMap.set(slidesEls[i], index);\n            }\n            if (isChanged) {\n                slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n            }\n        });\n        watch(realIndexRef, (realIndex, lastRealIndex) => {\n            if (realIndex === lastRealIndex)\n                return;\n            resetAutoplay();\n            if (sequenceLayoutRef.value) {\n                if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n                    const { value: length } = totalViewRef;\n                    if (realIndex === length - 2 && lastRealIndex === 1) {\n                        realIndex = 0;\n                    }\n                    else if (realIndex === 1 && lastRealIndex === length - 2) {\n                        realIndex = length - 1;\n                    }\n                }\n                translateTo(realIndex, speedRef.value);\n            }\n            else {\n                fixTranslate();\n            }\n        }, { immediate: true });\n        watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => toRealIndex(realIndexRef.value)));\n        watch(slideTranlatesRef, () => sequenceLayoutRef.value && fixTranslate(), {\n            deep: true\n        });\n        watch(sequenceLayoutRef, (value) => {\n            if (!value) {\n                inTransition = false;\n                // if the current mode does not support translate, reset the position of the wrapper\n                updateTranslate((previousTranslate = 0));\n            }\n            else {\n                fixTranslate();\n            }\n        });\n        const slidesControlListenersRef = computed(() => {\n            return {\n                onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n                onMousedown: props.draggable ? handleTouchstart : undefined,\n                onWheel: props.mousewheel ? handleMousewheel : undefined\n            };\n        });\n        const arrowSlotPropsRef = computed(() => (Object.assign(Object.assign({}, keep(carouselContext, [\n            'to',\n            'prev',\n            'next',\n            'isPrevDisabled',\n            'isNextDisabled'\n        ])), { total: displayTotalViewRef.value, currentIndex: mergedDisplayIndexRef.value })));\n        const dotSlotPropsRef = computed(() => ({\n            total: displayTotalViewRef.value,\n            currentIndex: mergedDisplayIndexRef.value,\n            to: carouselContext.to\n        }));\n        const caroulseExposedMethod = {\n            getCurrentIndex: () => mergedDisplayIndexRef.value,\n            to,\n            prev,\n            next\n        };\n        const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { dotSize, dotColor, dotColorActive, dotColorFocus, dotLineWidth, dotLineWidthActive, arrowColor } } = themeRef.value;\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-dot-color': dotColor,\n                '--n-dot-color-focus': dotColorFocus,\n                '--n-dot-color-active': dotColorActive,\n                '--n-dot-size': dotSize,\n                '--n-dot-line-width': dotLineWidth,\n                '--n-dot-line-width-active': dotLineWidthActive,\n                '--n-arrow-color': arrowColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('carousel', undefined, cssVarsRef, props)\n            : undefined;\n        return Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, selfElRef,\n            slidesElRef, slideVNodes: slideVNodesRef, duplicatedable: duplicatedableRef, userWantsControl: userWantsControlRef, autoSlideSize: autoSlideSizeRef, displayIndex: mergedDisplayIndexRef, realIndex: realIndexRef, slideStyles: slideStylesRef, translateStyle: translateStyleRef, slidesControlListeners: slidesControlListenersRef, handleTransitionEnd,\n            handleResize,\n            handleSlideResize,\n            handleMouseenter,\n            handleMouseleave, isActive: isDisplayActive, arrowSlotProps: arrowSlotPropsRef, dotSlotProps: dotSlotPropsRef }, caroulseExposedMethod), { cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });\n    },\n    render() {\n        var _a;\n        const { mergedClsPrefix, showArrow, userWantsControl, slideStyles, dotType, dotPlacement, slidesControlListeners, transitionProps = {}, arrowSlotProps, dotSlotProps, $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot } } = this;\n        const children = (defaultSlot && flatten(defaultSlot())) || [];\n        let slides = filterCarouselItem(children);\n        if (!slides.length) {\n            slides = children.map((ch) => (h(NCarouselItem, null, {\n                default: () => cloneVNode(ch)\n            })));\n        }\n        if (this.duplicatedable) {\n            slides = addDuplicateSlides(slides);\n        }\n        this.slideVNodes.value = slides;\n        // When users need to customize the size of the slide,\n        // we listen to them to fix the current translate\n        if (this.autoSlideSize) {\n            slides = slides.map((slide) => (h(VResizeObserver, { onResize: this.handleSlideResize }, {\n                default: () => slide\n            })));\n        }\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        return (h(\"div\", Object.assign({ ref: \"selfElRef\", class: [\n                this.themeClass,\n                `${mergedClsPrefix}-carousel`,\n                this.direction === 'vertical' &&\n                    `${mergedClsPrefix}-carousel--vertical`,\n                this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,\n                `${mergedClsPrefix}-carousel--${dotPlacement}`,\n                `${mergedClsPrefix}-carousel--${this.direction}`,\n                `${mergedClsPrefix}-carousel--${this.effect}`,\n                userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`\n            ], style: this.cssVars }, slidesControlListeners, { onMouseenter: this.handleMouseenter, onMouseleave: this.handleMouseleave }),\n            h(VResizeObserver, { onResize: this.handleResize }, {\n                default: () => (h(\"div\", { ref: \"slidesElRef\", class: `${mergedClsPrefix}-carousel__slides`, role: \"listbox\", style: this.translateStyle, onTransitionend: this.handleTransitionEnd }, userWantsControl\n                    ? slides.map((slide, i) => (h(\"div\", { style: slideStyles[i], key: i }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n                        default: () => slide\n                    }), [[vShow, this.isActive(i)]]))))\n                    : slides))\n            }),\n            this.showDots &&\n                dotSlotProps.total > 1 &&\n                resolveSlotWithProps(dotsSlot, dotSlotProps, () => [\n                    h(NCarouselDots, { key: dotType + dotPlacement, total: dotSlotProps.total, currentIndex: dotSlotProps.currentIndex, dotType: dotType, trigger: this.trigger, keyboard: this.keyboard })\n                ]),\n            showArrow &&\n                resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [\n                    h(NCarouselArrow, null)\n                ])));\n    }\n});\nfunction filterCarouselItem(vnodes) {\n    return vnodes.reduce((carouselItems, vnode) => {\n        if (isCarouselItem(vnode)) {\n            carouselItems.push(vnode);\n        }\n        return carouselItems;\n    }, []);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}