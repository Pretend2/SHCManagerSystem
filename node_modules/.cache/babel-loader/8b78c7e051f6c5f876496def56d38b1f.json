{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n  constructor() {\n    super();\n    this.message = 'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n  }\n\n}\n\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\n\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n  const visitedKeys = new Set();\n  uncheckedKeys.forEach(uncheckedKey => {\n    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n\n    if (uncheckedTreeNode !== undefined) {\n      let nodeCursor = uncheckedTreeNode.parent;\n\n      while (nodeCursor !== null) {\n        if (nodeCursor.disabled) break;\n        if (visitedKeys.has(nodeCursor.key)) break;else {\n          visitedKeys.add(nodeCursor.key);\n        }\n        nodeCursor = nodeCursor.parent;\n      }\n    }\n  });\n  return visitedKeys;\n}\n\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n  const keysToRemove = [];\n  extendedCheckedKeySet.forEach(key => {\n    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n      keysToRemove.push(key);\n    }\n  });\n  keysToRemove.forEach(key => extendedCheckedKeySet.delete(key));\n  return extendedCheckedKeySet;\n}\n\nexport function getCheckedKeys(options, treeMate) {\n  const {\n    checkedKeys,\n    keysToCheck,\n    keysToUncheck,\n    indeterminateKeys,\n    cascade,\n    leafOnly,\n    checkStrategy,\n    allowNotLoaded\n  } = options;\n\n  if (!cascade) {\n    if (keysToCheck !== undefined) {\n      return {\n        checkedKeys: merge(checkedKeys, keysToCheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else if (keysToUncheck !== undefined) {\n      return {\n        checkedKeys: minus(checkedKeys, keysToUncheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else {\n      return {\n        checkedKeys: Array.from(checkedKeys),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    }\n  }\n\n  const {\n    levelTreeNodeMap\n  } = treeMate;\n  let extendedCheckedKeySet;\n\n  if (keysToUncheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n  } else if (keysToCheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n  } else {\n    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n  }\n\n  const checkStrategyIsParent = checkStrategy === 'parent';\n  const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n  const syntheticCheckedKeySet = extendedCheckedKeySet;\n  const syntheticIndeterminateKeySet = new Set();\n  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys())); // cascade check\n  // 1. if tree is fully loaded, it just works\n  // 2. if the tree is not fully loaded, we assume that keys which is in not\n  //    loaded tree are not in checked keys\n  //    for example:\n  //    a -- b(fully-loaded)   -- c(fully-loaded)\n  //      |- d(partial-loaded) -- ?e(not-loaded)\n  //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n  //    and `a`'s status\n\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const levelIsZero = level === 0; // it should exists, nor it is a bug\n\n    const levelTreeNodes = levelTreeNodeMap.get(level);\n\n    for (const levelTreeNode of levelTreeNodes) {\n      if (levelTreeNode.isLeaf) continue;\n      const {\n        key: levelTreeNodeKey,\n        shallowLoaded\n      } = levelTreeNode;\n\n      if (checkStrategyIsChild && shallowLoaded) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        levelTreeNode.children.forEach(v => {\n          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {\n            syntheticCheckedKeySet.delete(v.key);\n          }\n        });\n      }\n\n      if (levelTreeNode.disabled || !shallowLoaded) {\n        continue;\n      }\n\n      let fullyChecked = true;\n      let partialChecked = false;\n      let allDisabled = true; // it is shallow loaded, so `children` must exist\n\n      for (const childNode of levelTreeNode.children) {\n        const childKey = childNode.key;\n        if (childNode.disabled) continue;\n        if (allDisabled) allDisabled = false;\n\n        if (syntheticCheckedKeySet.has(childKey)) {\n          partialChecked = true;\n        } else if (syntheticIndeterminateKeySet.has(childKey)) {\n          partialChecked = true;\n          fullyChecked = false;\n          break;\n        } else {\n          fullyChecked = false;\n\n          if (partialChecked) {\n            break;\n          }\n        }\n      }\n\n      if (fullyChecked && !allDisabled) {\n        if (checkStrategyIsParent) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          levelTreeNode.children.forEach(v => {\n            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n              syntheticCheckedKeySet.delete(v.key);\n            }\n          });\n        }\n\n        syntheticCheckedKeySet.add(levelTreeNodeKey);\n      } else if (partialChecked) {\n        syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n      }\n\n      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n        syntheticCheckedKeySet.delete(levelTreeNodeKey);\n      }\n    }\n  }\n\n  return {\n    checkedKeys: Array.from(syntheticCheckedKeySet),\n    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n  };\n} // unchecking is safe when doing cascade uncheck in async mode\n\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n  const {\n    treeNodeMap,\n    getChildren\n  } = treeMate;\n  const visitedKeySet = new Set();\n  const extendedKeySet = new Set(checkedKeys);\n  checkedKeys.forEach(checkedKey => {\n    const checkedTreeNode = treeNodeMap.get(checkedKey);\n\n    if (checkedTreeNode !== undefined) {\n      traverseWithCb(checkedTreeNode, treeNode => {\n        if (treeNode.disabled) {\n          return TRAVERSE_COMMAND.STOP;\n        }\n\n        const {\n          key\n        } = treeNode;\n        if (visitedKeySet.has(key)) return;\n        visitedKeySet.add(key); // Adding keys before loaded check is okay, since if not valid error\n        // would be thrown\n\n        extendedKeySet.add(key);\n\n        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n          if (isUnchecking) {\n            return TRAVERSE_COMMAND.STOP;\n          } else if (!allowNotLoaded) {\n            throw new SubtreeNotLoadedError();\n          }\n        }\n      });\n    }\n  });\n  return extendedKeySet;\n}","map":{"version":3,"names":["isExpilicitlyNotLoaded","merge","minus","traverseWithCb","TRAVERSE_COMMAND","SubtreeNotLoadedError","Error","constructor","message","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","concat","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","Set","forEach","uncheckedKey","uncheckedTreeNode","treeNodeMap","get","undefined","nodeCursor","parent","disabled","has","key","add","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","keysToRemove","push","delete","getCheckedKeys","options","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","Array","from","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","Math","max","apply","keys","level","levelIsZero","levelTreeNodes","levelTreeNode","isLeaf","levelTreeNodeKey","shallowLoaded","children","v","fullyChecked","partialChecked","allDisabled","childNode","childKey","isUnchecking","getChildren","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","treeNode","STOP","rawNode"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/treemate/es/check.js"],"sourcesContent":["import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}