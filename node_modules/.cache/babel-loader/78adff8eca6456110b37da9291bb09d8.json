{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([c('.v-binder-follower-container', {\n  position: 'absolute',\n  left: '0',\n  right: '0',\n  top: '0',\n  height: '0',\n  pointerEvents: 'none',\n  zIndex: 'auto'\n}), c('.v-binder-follower-content', {\n  position: 'absolute',\n  zIndex: 'auto'\n}, [c('> *', {\n  pointerEvents: 'all'\n})])]);\nexport default defineComponent({\n  name: 'Follower',\n  inheritAttrs: false,\n  props: {\n    show: Boolean,\n    enabled: {\n      type: Boolean,\n      default: undefined\n    },\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n    syncTrigger: {\n      type: Array,\n      default: ['resize', 'scroll']\n    },\n    to: [String, Object],\n    flip: {\n      type: Boolean,\n      default: true\n    },\n    internalShift: Boolean,\n    x: Number,\n    y: Number,\n    width: String,\n    minWidth: String,\n    containerClass: String,\n    teleportDisabled: Boolean,\n    zindexable: {\n      type: Boolean,\n      default: true\n    },\n    zIndex: Number,\n    overlap: Boolean\n  },\n\n  setup(props) {\n    const VBinder = inject('VBinder');\n    const mergedEnabledRef = useMemo(() => {\n      return props.enabled !== undefined ? props.enabled : props.show;\n    });\n    const followerRef = ref(null);\n    const offsetContainerRef = ref(null);\n\n    const ensureListeners = () => {\n      const {\n        syncTrigger\n      } = props;\n\n      if (syncTrigger.includes('scroll')) {\n        VBinder.addScrollListener(syncPosition);\n      }\n\n      if (syncTrigger.includes('resize')) {\n        VBinder.addResizeListener(syncPosition);\n      }\n    };\n\n    const removeListeners = () => {\n      VBinder.removeScrollListener(syncPosition);\n      VBinder.removeResizeListener(syncPosition);\n    };\n\n    onMounted(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n        ensureListeners();\n      }\n    });\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/binder',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onBeforeUnmount(() => {\n      removeListeners();\n    });\n    onFontsReady(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n      }\n    });\n\n    const syncPosition = () => {\n      if (!mergedEnabledRef.value) {\n        return;\n      }\n\n      const follower = followerRef.value; // sometimes watched props change before its dom is ready\n      // for example: show=false, x=undefined, y=undefined\n      //              show=true,  x=0,         y=0\n      // will cause error\n      // I may optimize the watch start point later\n\n      if (follower === null) return;\n      const target = VBinder.targetRef;\n      const {\n        x,\n        y,\n        overlap\n      } = props;\n      const targetRect = x !== undefined && y !== undefined ? getPointRect(x, y) : getRect(target);\n      follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n      follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n      const {\n        width,\n        minWidth,\n        placement,\n        internalShift,\n        flip\n      } = props;\n      follower.setAttribute('v-placement', placement);\n\n      if (overlap) {\n        follower.setAttribute('v-overlap', '');\n      } else {\n        follower.removeAttribute('v-overlap');\n      }\n\n      const {\n        style\n      } = follower;\n\n      if (width === 'target') {\n        style.width = `${targetRect.width}px`;\n      } else if (width !== undefined) {\n        style.width = width;\n      } else {\n        style.width = '';\n      }\n\n      if (minWidth === 'target') {\n        style.minWidth = `${targetRect.width}px`;\n      } else if (minWidth !== undefined) {\n        style.minWidth = minWidth;\n      } else {\n        style.minWidth = '';\n      }\n\n      const followerRect = getRect(follower);\n      const offsetContainerRect = getRect(offsetContainerRef.value);\n      const {\n        left: offsetLeftToStandardPlacement,\n        top: offsetTopToStandardPlacement,\n        placement: properPlacement\n      } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n      const {\n        left,\n        top,\n        transform\n      } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap); // we assume that the content size doesn't change after flip,\n      // nor we need to make sync logic more complex\n\n      follower.setAttribute('v-placement', properPlacement);\n      follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n      follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n      follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n      follower.style.setProperty('--v-transform-origin', properTransformOrigin);\n      follower.style.transformOrigin = properTransformOrigin;\n    };\n\n    watch(mergedEnabledRef, value => {\n      if (value) {\n        ensureListeners();\n        syncOnNextTick();\n      } else {\n        removeListeners();\n      }\n    });\n\n    const syncOnNextTick = () => {\n      nextTick().then(syncPosition).catch(e => console.error(e));\n    };\n\n    ['placement', 'x', 'y', 'internalShift', 'flip', 'width', 'overlap', 'minWidth'].forEach(prop => {\n      watch(toRef(props, prop), syncPosition);\n    });\n    ['teleportDisabled'].forEach(prop => {\n      watch(toRef(props, prop), syncOnNextTick);\n    });\n    watch(toRef(props, 'syncTrigger'), value => {\n      if (!value.includes('resize')) {\n        VBinder.removeResizeListener(syncPosition);\n      } else {\n        VBinder.addResizeListener(syncPosition);\n      }\n\n      if (!value.includes('scroll')) {\n        VBinder.removeScrollListener(syncPosition);\n      } else {\n        VBinder.addScrollListener(syncPosition);\n      }\n    });\n    const isMountedRef = useIsMounted();\n    const mergedToRef = useMemo(() => {\n      const {\n        to\n      } = props;\n      if (to !== undefined) return to;\n\n      if (isMountedRef.value) {\n        // TODO: find proper container\n        return undefined;\n      }\n\n      return undefined;\n    });\n    return {\n      VBinder,\n      mergedEnabled: mergedEnabledRef,\n      offsetContainerRef,\n      followerRef,\n      mergedTo: mergedToRef,\n      syncPosition\n    };\n  },\n\n  render() {\n    return h(LazyTeleport, {\n      show: this.show,\n      to: this.mergedTo,\n      disabled: this.teleportDisabled\n    }, {\n      default: () => {\n        var _a, _b;\n\n        const vNode = h('div', {\n          class: ['v-binder-follower-container', this.containerClass],\n          ref: 'offsetContainerRef'\n        }, [h('div', {\n          class: 'v-binder-follower-content',\n          ref: 'followerRef'\n        }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))]);\n\n        if (this.zindexable) {\n          return withDirectives(vNode, [[zindexable, {\n            enabled: this.mergedEnabled,\n            zIndex: this.zIndex\n          }]]);\n        }\n\n        return vNode;\n      }\n    });\n  }\n\n});","map":{"version":3,"names":["h","defineComponent","inject","nextTick","watch","toRef","ref","onMounted","onBeforeUnmount","withDirectives","zindexable","useMemo","useIsMounted","onFontsReady","useSsrAdapter","c","cssrAnchorMetaName","LazyTeleport","getPlacementAndOffsetOfFollower","getProperTransformOrigin","getOffset","getPointRect","getRect","style","position","left","right","top","height","pointerEvents","zIndex","name","inheritAttrs","props","show","Boolean","enabled","type","default","undefined","placement","String","syncTrigger","Array","to","Object","flip","internalShift","x","Number","y","width","minWidth","containerClass","teleportDisabled","overlap","setup","VBinder","mergedEnabledRef","followerRef","offsetContainerRef","ensureListeners","includes","addScrollListener","syncPosition","addResizeListener","removeListeners","removeScrollListener","removeResizeListener","value","ssrAdapter","mount","id","head","anchorMetaName","ssr","follower","target","targetRef","targetRect","setProperty","Math","round","setAttribute","removeAttribute","followerRect","offsetContainerRect","offsetLeftToStandardPlacement","offsetTopToStandardPlacement","properPlacement","properTransformOrigin","transform","transformOrigin","syncOnNextTick","then","catch","e","console","error","forEach","prop","isMountedRef","mergedToRef","mergedEnabled","mergedTo","render","disabled","_a","_b","vNode","class","$slots","call"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/vueuc/es/binder/src/Follower.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([\n    c('.v-binder-follower-container', {\n        position: 'absolute',\n        left: '0',\n        right: '0',\n        top: '0',\n        height: '0',\n        pointerEvents: 'none',\n        zIndex: 'auto'\n    }),\n    c('.v-binder-follower-content', {\n        position: 'absolute',\n        zIndex: 'auto'\n    }, [\n        c('> *', {\n            pointerEvents: 'all'\n        })\n    ])\n]);\nexport default defineComponent({\n    name: 'Follower',\n    inheritAttrs: false,\n    props: {\n        show: Boolean,\n        enabled: {\n            type: Boolean,\n            default: undefined\n        },\n        placement: {\n            type: String,\n            default: 'bottom'\n        },\n        syncTrigger: {\n            type: Array,\n            default: ['resize', 'scroll']\n        },\n        to: [String, Object],\n        flip: {\n            type: Boolean,\n            default: true\n        },\n        internalShift: Boolean,\n        x: Number,\n        y: Number,\n        width: String,\n        minWidth: String,\n        containerClass: String,\n        teleportDisabled: Boolean,\n        zindexable: {\n            type: Boolean,\n            default: true\n        },\n        zIndex: Number,\n        overlap: Boolean\n    },\n    setup(props) {\n        const VBinder = inject('VBinder');\n        const mergedEnabledRef = useMemo(() => {\n            return props.enabled !== undefined ? props.enabled : props.show;\n        });\n        const followerRef = ref(null);\n        const offsetContainerRef = ref(null);\n        const ensureListeners = () => {\n            const { syncTrigger } = props;\n            if (syncTrigger.includes('scroll')) {\n                VBinder.addScrollListener(syncPosition);\n            }\n            if (syncTrigger.includes('resize')) {\n                VBinder.addResizeListener(syncPosition);\n            }\n        };\n        const removeListeners = () => {\n            VBinder.removeScrollListener(syncPosition);\n            VBinder.removeResizeListener(syncPosition);\n        };\n        onMounted(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n                ensureListeners();\n            }\n        });\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/binder',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onBeforeUnmount(() => {\n            removeListeners();\n        });\n        onFontsReady(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n            }\n        });\n        const syncPosition = () => {\n            if (!mergedEnabledRef.value) {\n                return;\n            }\n            const follower = followerRef.value;\n            // sometimes watched props change before its dom is ready\n            // for example: show=false, x=undefined, y=undefined\n            //              show=true,  x=0,         y=0\n            // will cause error\n            // I may optimize the watch start point later\n            if (follower === null)\n                return;\n            const target = VBinder.targetRef;\n            const { x, y, overlap } = props;\n            const targetRect = x !== undefined && y !== undefined\n                ? getPointRect(x, y)\n                : getRect(target);\n            follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n            follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n            const { width, minWidth, placement, internalShift, flip } = props;\n            follower.setAttribute('v-placement', placement);\n            if (overlap) {\n                follower.setAttribute('v-overlap', '');\n            }\n            else {\n                follower.removeAttribute('v-overlap');\n            }\n            const { style } = follower;\n            if (width === 'target') {\n                style.width = `${targetRect.width}px`;\n            }\n            else if (width !== undefined) {\n                style.width = width;\n            }\n            else {\n                style.width = '';\n            }\n            if (minWidth === 'target') {\n                style.minWidth = `${targetRect.width}px`;\n            }\n            else if (minWidth !== undefined) {\n                style.minWidth = minWidth;\n            }\n            else {\n                style.minWidth = '';\n            }\n            const followerRect = getRect(follower);\n            const offsetContainerRect = getRect(offsetContainerRef.value);\n            const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n            const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);\n            // we assume that the content size doesn't change after flip,\n            // nor we need to make sync logic more complex\n            follower.setAttribute('v-placement', properPlacement);\n            follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n            follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n            follower.style.setProperty('--v-transform-origin', properTransformOrigin);\n            follower.style.transformOrigin = properTransformOrigin;\n        };\n        watch(mergedEnabledRef, (value) => {\n            if (value) {\n                ensureListeners();\n                syncOnNextTick();\n            }\n            else {\n                removeListeners();\n            }\n        });\n        const syncOnNextTick = () => {\n            nextTick()\n                .then(syncPosition)\n                .catch((e) => console.error(e));\n        };\n        [\n            'placement',\n            'x',\n            'y',\n            'internalShift',\n            'flip',\n            'width',\n            'overlap',\n            'minWidth'\n        ].forEach((prop) => {\n            watch(toRef(props, prop), syncPosition);\n        });\n        ['teleportDisabled'].forEach((prop) => {\n            watch(toRef(props, prop), syncOnNextTick);\n        });\n        watch(toRef(props, 'syncTrigger'), (value) => {\n            if (!value.includes('resize')) {\n                VBinder.removeResizeListener(syncPosition);\n            }\n            else {\n                VBinder.addResizeListener(syncPosition);\n            }\n            if (!value.includes('scroll')) {\n                VBinder.removeScrollListener(syncPosition);\n            }\n            else {\n                VBinder.addScrollListener(syncPosition);\n            }\n        });\n        const isMountedRef = useIsMounted();\n        const mergedToRef = useMemo(() => {\n            const { to } = props;\n            if (to !== undefined)\n                return to;\n            if (isMountedRef.value) {\n                // TODO: find proper container\n                return undefined;\n            }\n            return undefined;\n        });\n        return {\n            VBinder,\n            mergedEnabled: mergedEnabledRef,\n            offsetContainerRef,\n            followerRef,\n            mergedTo: mergedToRef,\n            syncPosition\n        };\n    },\n    render() {\n        return h(LazyTeleport, {\n            show: this.show,\n            to: this.mergedTo,\n            disabled: this.teleportDisabled\n        }, {\n            default: () => {\n                var _a, _b;\n                const vNode = h('div', {\n                    class: ['v-binder-follower-container', this.containerClass],\n                    ref: 'offsetContainerRef'\n                }, [\n                    h('div', {\n                        class: 'v-binder-follower-content',\n                        ref: 'followerRef'\n                    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))\n                ]);\n                if (this.zindexable) {\n                    return withDirectives(vNode, [\n                        [\n                            zindexable,\n                            {\n                                enabled: this.mergedEnabled,\n                                zIndex: this.zIndex\n                            }\n                        ]\n                    ]);\n                }\n                return vNode;\n            }\n        });\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}