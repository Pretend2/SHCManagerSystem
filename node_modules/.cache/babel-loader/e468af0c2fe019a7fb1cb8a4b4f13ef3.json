{"ast":null,"code":"export const resolveOptionsAndHash = (options = {}) => {\n  var _a;\n\n  const {\n    root = null\n  } = options;\n  return {\n    hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold) ? options.threshold.join(',') : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n    options: Object.assign(Object.assign({}, options), {\n      root: (typeof root === 'string' ? document.querySelector(root) : root) || document.documentElement\n    })\n  };\n}; // root -> options -> [observer, elements]\n\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n  if (!el) return () => {};\n  const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n  const {\n    root\n  } = resolvedOptionsAndHash.options;\n  let rootObservers;\n\n  const _rootObservers = observers.get(root);\n\n  if (_rootObservers) {\n    rootObservers = _rootObservers;\n  } else {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n\n  let observer;\n  let observerAndObservedElements;\n\n  if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n    observerAndObservedElements = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    rootObservers.get(resolvedOptionsAndHash.hash);\n\n    if (!observerAndObservedElements[1].has(el)) {\n      observer = observerAndObservedElements[0];\n      observerAndObservedElements[1].add(el);\n      observer.observe(el);\n    }\n  } else {\n    observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const _unobserve = unobserveHandleMap.get(entry.target);\n\n          const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n\n          if (_unobserve) _unobserve();\n\n          if (_shouldStartLoadingRef) {\n            _shouldStartLoadingRef.value = true;\n          }\n        }\n      });\n    }, resolvedOptionsAndHash.options);\n    observer.observe(el);\n    observerAndObservedElements = [observer, new Set([el])];\n    rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n  }\n\n  let unobservered = false;\n\n  const unobserve = () => {\n    if (unobservered) return;\n    unobserveHandleMap.delete(el);\n    shouldStartLoadingRefMap.delete(el);\n    unobservered = true;\n\n    if (observerAndObservedElements[1].has(el)) {\n      observerAndObservedElements[0].unobserve(el);\n      observerAndObservedElements[1].delete(el);\n    }\n\n    if (observerAndObservedElements[1].size <= 0) {\n      rootObservers.delete(resolvedOptionsAndHash.hash);\n    }\n\n    if (!rootObservers.size) {\n      observers.delete(root);\n    }\n  };\n\n  unobserveHandleMap.set(el, unobserve);\n  shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n  return unobserve;\n};","map":{"version":3,"names":["resolveOptionsAndHash","options","_a","root","hash","rootMargin","Array","isArray","threshold","join","Object","assign","document","querySelector","documentElement","observers","WeakMap","unobserveHandleMap","shouldStartLoadingRefMap","observeIntersection","el","shouldStartLoadingRef","resolvedOptionsAndHash","rootObservers","_rootObservers","get","Map","set","observer","observerAndObservedElements","has","add","observe","IntersectionObserver","entries","forEach","entry","isIntersecting","_unobserve","target","_shouldStartLoadingRef","value","Set","unobservered","unobserve","delete","size"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/naive-ui/es/image/src/utils.js"],"sourcesContent":["export const resolveOptionsAndHash = (options = {}) => {\n    var _a;\n    const { root = null } = options;\n    return {\n        hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold)\n            ? options.threshold.join(',')\n            : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n        options: Object.assign(Object.assign({}, options), { root: (typeof root === 'string' ? document.querySelector(root) : root) ||\n                document.documentElement })\n    };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n    if (!el)\n        return () => { };\n    const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n    const { root } = resolvedOptionsAndHash.options;\n    let rootObservers;\n    const _rootObservers = observers.get(root);\n    if (_rootObservers) {\n        rootObservers = _rootObservers;\n    }\n    else {\n        rootObservers = new Map();\n        observers.set(root, rootObservers);\n    }\n    let observer;\n    let observerAndObservedElements;\n    if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n        observerAndObservedElements =\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            rootObservers.get(resolvedOptionsAndHash.hash);\n        if (!observerAndObservedElements[1].has(el)) {\n            observer = observerAndObservedElements[0];\n            observerAndObservedElements[1].add(el);\n            observer.observe(el);\n        }\n    }\n    else {\n        observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    const _unobserve = unobserveHandleMap.get(entry.target);\n                    const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n                    if (_unobserve)\n                        _unobserve();\n                    if (_shouldStartLoadingRef) {\n                        _shouldStartLoadingRef.value = true;\n                    }\n                }\n            });\n        }, resolvedOptionsAndHash.options);\n        observer.observe(el);\n        observerAndObservedElements = [observer, new Set([el])];\n        rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n    }\n    let unobservered = false;\n    const unobserve = () => {\n        if (unobservered)\n            return;\n        unobserveHandleMap.delete(el);\n        shouldStartLoadingRefMap.delete(el);\n        unobservered = true;\n        if (observerAndObservedElements[1].has(el)) {\n            observerAndObservedElements[0].unobserve(el);\n            observerAndObservedElements[1].delete(el);\n        }\n        if (observerAndObservedElements[1].size <= 0) {\n            rootObservers.delete(resolvedOptionsAndHash.hash);\n        }\n        if (!rootObservers.size) {\n            observers.delete(root);\n        }\n    };\n    unobserveHandleMap.set(el, unobserve);\n    shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n    return unobserve;\n};\n"],"mappings":"AAAA,OAAO,MAAMA,qBAAqB,GAAG,CAACC,OAAO,GAAG,EAAX,KAAkB;EACnD,IAAIC,EAAJ;;EACA,MAAM;IAAEC,IAAI,GAAG;EAAT,IAAkBF,OAAxB;EACA,OAAO;IACHG,IAAI,EAAG,GAAEH,OAAO,CAACI,UAAR,IAAsB,iBAAkB,IAAGC,KAAK,CAACC,OAAN,CAAcN,OAAO,CAACO,SAAtB,IAC9CP,OAAO,CAACO,SAAR,CAAkBC,IAAlB,CAAuB,GAAvB,CAD8C,GAE9C,CAACP,EAAE,GAAGD,OAAO,CAACO,SAAd,MAA6B,IAA7B,IAAqCN,EAAE,KAAK,KAAK,CAAjD,GAAqDA,EAArD,GAA0D,GAAI,EAHjE;IAIHD,OAAO,EAAES,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,OAAlB,CAAd,EAA0C;MAAEE,IAAI,EAAE,CAAC,OAAOA,IAAP,KAAgB,QAAhB,GAA2BS,QAAQ,CAACC,aAAT,CAAuBV,IAAvB,CAA3B,GAA0DA,IAA3D,KACnDS,QAAQ,CAACE;IADkC,CAA1C;EAJN,CAAP;AAOH,CAVM,C,CAWP;;AACA,MAAMC,SAAS,GAAG,IAAIC,OAAJ,EAAlB;AACA,MAAMC,kBAAkB,GAAG,IAAID,OAAJ,EAA3B;AACA,MAAME,wBAAwB,GAAG,IAAIF,OAAJ,EAAjC;AACA,OAAO,MAAMG,mBAAmB,GAAG,CAACC,EAAD,EAAKnB,OAAL,EAAcoB,qBAAd,KAAwC;EACvE,IAAI,CAACD,EAAL,EACI,OAAO,MAAM,CAAG,CAAhB;EACJ,MAAME,sBAAsB,GAAGtB,qBAAqB,CAACC,OAAD,CAApD;EACA,MAAM;IAAEE;EAAF,IAAWmB,sBAAsB,CAACrB,OAAxC;EACA,IAAIsB,aAAJ;;EACA,MAAMC,cAAc,GAAGT,SAAS,CAACU,GAAV,CAActB,IAAd,CAAvB;;EACA,IAAIqB,cAAJ,EAAoB;IAChBD,aAAa,GAAGC,cAAhB;EACH,CAFD,MAGK;IACDD,aAAa,GAAG,IAAIG,GAAJ,EAAhB;IACAX,SAAS,CAACY,GAAV,CAAcxB,IAAd,EAAoBoB,aAApB;EACH;;EACD,IAAIK,QAAJ;EACA,IAAIC,2BAAJ;;EACA,IAAIN,aAAa,CAACO,GAAd,CAAkBR,sBAAsB,CAAClB,IAAzC,CAAJ,EAAoD;IAChDyB,2BAA2B,GACvB;IACAN,aAAa,CAACE,GAAd,CAAkBH,sBAAsB,CAAClB,IAAzC,CAFJ;;IAGA,IAAI,CAACyB,2BAA2B,CAAC,CAAD,CAA3B,CAA+BC,GAA/B,CAAmCV,EAAnC,CAAL,EAA6C;MACzCQ,QAAQ,GAAGC,2BAA2B,CAAC,CAAD,CAAtC;MACAA,2BAA2B,CAAC,CAAD,CAA3B,CAA+BE,GAA/B,CAAmCX,EAAnC;MACAQ,QAAQ,CAACI,OAAT,CAAiBZ,EAAjB;IACH;EACJ,CATD,MAUK;IACDQ,QAAQ,GAAG,IAAIK,oBAAJ,CAA0BC,OAAD,IAAa;MAC7CA,OAAO,CAACC,OAAR,CAAiBC,KAAD,IAAW;QACvB,IAAIA,KAAK,CAACC,cAAV,EAA0B;UACtB,MAAMC,UAAU,GAAGrB,kBAAkB,CAACQ,GAAnB,CAAuBW,KAAK,CAACG,MAA7B,CAAnB;;UACA,MAAMC,sBAAsB,GAAGtB,wBAAwB,CAACO,GAAzB,CAA6BW,KAAK,CAACG,MAAnC,CAA/B;;UACA,IAAID,UAAJ,EACIA,UAAU;;UACd,IAAIE,sBAAJ,EAA4B;YACxBA,sBAAsB,CAACC,KAAvB,GAA+B,IAA/B;UACH;QACJ;MACJ,CAVD;IAWH,CAZU,EAYRnB,sBAAsB,CAACrB,OAZf,CAAX;IAaA2B,QAAQ,CAACI,OAAT,CAAiBZ,EAAjB;IACAS,2BAA2B,GAAG,CAACD,QAAD,EAAW,IAAIc,GAAJ,CAAQ,CAACtB,EAAD,CAAR,CAAX,CAA9B;IACAG,aAAa,CAACI,GAAd,CAAkBL,sBAAsB,CAAClB,IAAzC,EAA+CyB,2BAA/C;EACH;;EACD,IAAIc,YAAY,GAAG,KAAnB;;EACA,MAAMC,SAAS,GAAG,MAAM;IACpB,IAAID,YAAJ,EACI;IACJ1B,kBAAkB,CAAC4B,MAAnB,CAA0BzB,EAA1B;IACAF,wBAAwB,CAAC2B,MAAzB,CAAgCzB,EAAhC;IACAuB,YAAY,GAAG,IAAf;;IACA,IAAId,2BAA2B,CAAC,CAAD,CAA3B,CAA+BC,GAA/B,CAAmCV,EAAnC,CAAJ,EAA4C;MACxCS,2BAA2B,CAAC,CAAD,CAA3B,CAA+Be,SAA/B,CAAyCxB,EAAzC;MACAS,2BAA2B,CAAC,CAAD,CAA3B,CAA+BgB,MAA/B,CAAsCzB,EAAtC;IACH;;IACD,IAAIS,2BAA2B,CAAC,CAAD,CAA3B,CAA+BiB,IAA/B,IAAuC,CAA3C,EAA8C;MAC1CvB,aAAa,CAACsB,MAAd,CAAqBvB,sBAAsB,CAAClB,IAA5C;IACH;;IACD,IAAI,CAACmB,aAAa,CAACuB,IAAnB,EAAyB;MACrB/B,SAAS,CAAC8B,MAAV,CAAiB1C,IAAjB;IACH;EACJ,CAhBD;;EAiBAc,kBAAkB,CAACU,GAAnB,CAAuBP,EAAvB,EAA2BwB,SAA3B;EACA1B,wBAAwB,CAACS,GAAzB,CAA6BP,EAA7B,EAAiCC,qBAAjC;EACA,OAAOuB,SAAP;AACH,CAjEM"},"metadata":{},"sourceType":"module"}