{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { trapOn, trapOff } from './traps';\nimport { getEventTarget } from './utils'; // currently `once` and `passive` is not supported\n\nfunction createDelegate() {\n  if (typeof window === 'undefined') {\n    return {\n      on: () => {},\n      off: () => {}\n    };\n  }\n\n  const propagationStopped = new WeakMap();\n  const immediatePropagationStopped = new WeakMap();\n\n  function trackPropagation() {\n    propagationStopped.set(this, true);\n  }\n\n  function trackImmediate() {\n    propagationStopped.set(this, true);\n    immediatePropagationStopped.set(this, true);\n  }\n\n  function spy(event, propName, fn) {\n    const source = event[propName];\n\n    event[propName] = function () {\n      fn.apply(event, arguments);\n      return source.apply(event, arguments);\n    };\n\n    return event;\n  }\n\n  function unspy(event, propName) {\n    event[propName] = Event.prototype[propName];\n  }\n\n  const currentTargets = new WeakMap();\n  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n\n  function getCurrentTarget() {\n    var _a;\n\n    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  function defineCurrentTarget(event, getter) {\n    if (currentTargetDescriptor === undefined) return;\n    Object.defineProperty(event, 'currentTarget', {\n      configurable: true,\n      enumerable: true,\n      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n    });\n  }\n\n  const phaseToTypeToElToHandlers = {\n    bubble: {},\n    capture: {}\n  };\n  const typeToWindowEventHandlers = {};\n\n  function createUnifiedHandler() {\n    const delegeteHandler = function (e) {\n      const {\n        type,\n        eventPhase,\n        bubbles\n      } = e;\n      const target = getEventTarget(e);\n      if (eventPhase === 2) return;\n      const phase = eventPhase === 1 ? 'capture' : 'bubble';\n      let cursor = target;\n      const path = []; // collecting bubble path\n\n      while (true) {\n        if (cursor === null) cursor = window;\n        path.push(cursor);\n\n        if (cursor === window) {\n          break;\n        } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n        cursor = cursor.parentNode || null;\n      }\n\n      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n      spy(e, 'stopPropagation', trackPropagation);\n      spy(e, 'stopImmediatePropagation', trackImmediate);\n      defineCurrentTarget(e, getCurrentTarget);\n\n      if (phase === 'capture') {\n        if (captureElToHandlers === undefined) return; // capture\n\n        for (let i = path.length - 1; i >= 0; --i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = captureElToHandlers.get(target);\n\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n\n          if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n            const bubbleHandlers = bubbleElToHandlers.get(target);\n\n            if (bubbleHandlers !== undefined) {\n              for (const handler of bubbleHandlers) {\n                if (immediatePropagationStopped.has(e)) break;\n                handler(e);\n              }\n            }\n          }\n        }\n      } else if (phase === 'bubble') {\n        if (bubbleElToHandlers === undefined) return; // bubble\n\n        for (let i = 0; i < path.length; ++i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = bubbleElToHandlers.get(target);\n\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n        }\n      }\n\n      unspy(e, 'stopPropagation');\n      unspy(e, 'stopImmediatePropagation');\n      defineCurrentTarget(e);\n    };\n\n    delegeteHandler.displayName = 'evtdUnifiedHandler';\n    return delegeteHandler;\n  }\n\n  function createUnifiedWindowEventHandler() {\n    const delegateHandler = function (e) {\n      const {\n        type,\n        eventPhase\n      } = e;\n      if (eventPhase !== 2) return;\n      const handlers = typeToWindowEventHandlers[type];\n      if (handlers === undefined) return;\n      handlers.forEach(handler => handler(e));\n    };\n\n    delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n    return delegateHandler;\n  }\n\n  const unifiedHandler = createUnifiedHandler();\n  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n\n  function ensureElToHandlers(phase, type) {\n    const phaseHandlers = phaseToTypeToElToHandlers[phase];\n\n    if (phaseHandlers[type] === undefined) {\n      phaseHandlers[type] = new Map();\n      window.addEventListener(type, unifiedHandler, phase === 'capture');\n    }\n\n    return phaseHandlers[type];\n  }\n\n  function ensureWindowEventHandlers(type) {\n    const windowEventHandlers = typeToWindowEventHandlers[type];\n\n    if (windowEventHandlers === undefined) {\n      typeToWindowEventHandlers[type] = new Set();\n      window.addEventListener(type, unfiendWindowEventHandler);\n    }\n\n    return typeToWindowEventHandlers[type];\n  }\n\n  function ensureHandlers(elToHandlers, el) {\n    let elHandlers = elToHandlers.get(el);\n\n    if (elHandlers === undefined) {\n      elToHandlers.set(el, elHandlers = new Set());\n    }\n\n    return elHandlers;\n  }\n\n  function handlerExist(el, phase, type, handler) {\n    const elToHandlers = phaseToTypeToElToHandlers[phase][type]; // phase ${type} event has handlers\n\n    if (elToHandlers !== undefined) {\n      const handlers = elToHandlers.get(el); // phase using el with ${type} event has handlers\n\n      if (handlers !== undefined) {\n        if (handlers.has(handler)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function windowEventHandlerExist(type, handler) {\n    const handlers = typeToWindowEventHandlers[type];\n\n    if (handlers !== undefined) {\n      if (handlers.has(handler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function on(type, el, handler, options) {\n    let mergedHandler;\n\n    if (typeof options === 'object' && options.once === true) {\n      mergedHandler = e => {\n        off(type, el, mergedHandler, options);\n        handler(e);\n      };\n    } else {\n      mergedHandler = handler;\n    }\n\n    const trapped = trapOn(type, el, mergedHandler, options);\n    if (trapped) return;\n    const phase = options === true || typeof options === 'object' && options.capture === true ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n    if (!handlers.has(mergedHandler)) handlers.add(mergedHandler);\n\n    if (el === window) {\n      const windowEventHandlers = ensureWindowEventHandlers(type);\n\n      if (!windowEventHandlers.has(mergedHandler)) {\n        windowEventHandlers.add(mergedHandler);\n      }\n    }\n  }\n\n  function off(type, el, handler, options) {\n    const trapped = trapOff(type, el, handler, options);\n    if (trapped) return;\n    const capture = options === true || typeof options === 'object' && options.capture === true;\n    const phase = capture ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n\n    if (el === window) {\n      const mirrorPhase = capture ? 'bubble' : 'capture';\n\n      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        windowEventHandlers.delete(handler);\n\n        if (windowEventHandlers.size === 0) {\n          window.removeEventListener(type, unfiendWindowEventHandler);\n          typeToWindowEventHandlers[type] = undefined;\n        }\n      }\n    }\n\n    if (handlers.has(handler)) handlers.delete(handler);\n\n    if (handlers.size === 0) {\n      elToHandlers.delete(el);\n    }\n\n    if (elToHandlers.size === 0) {\n      window.removeEventListener(type, unifiedHandler, phase === 'capture');\n      phaseToTypeToElToHandlers[phase][type] = undefined;\n    }\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nconst {\n  on,\n  off\n} = createDelegate();\nexport { on, off };","map":{"version":3,"names":["trapOn","trapOff","getEventTarget","createDelegate","window","on","off","propagationStopped","WeakMap","immediatePropagationStopped","trackPropagation","set","trackImmediate","spy","event","propName","fn","source","apply","arguments","unspy","Event","prototype","currentTargets","currentTargetDescriptor","Object","getOwnPropertyDescriptor","getCurrentTarget","_a","get","defineCurrentTarget","getter","undefined","defineProperty","configurable","enumerable","phaseToTypeToElToHandlers","bubble","capture","typeToWindowEventHandlers","createUnifiedHandler","delegeteHandler","e","type","eventPhase","bubbles","target","phase","cursor","path","push","parentNode","captureElToHandlers","bubbleElToHandlers","i","length","has","handlers","handler","bubbleHandlers","displayName","createUnifiedWindowEventHandler","delegateHandler","forEach","unifiedHandler","unfiendWindowEventHandler","ensureElToHandlers","phaseHandlers","Map","addEventListener","ensureWindowEventHandlers","windowEventHandlers","Set","ensureHandlers","elToHandlers","el","elHandlers","handlerExist","windowEventHandlerExist","options","mergedHandler","once","trapped","add","mirrorPhase","delete","size","removeEventListener"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/evtd/es/delegate.js"],"sourcesContent":["import { trapOn, trapOff } from './traps';\nimport { getEventTarget } from './utils';\n// currently `once` and `passive` is not supported\nfunction createDelegate() {\n    if (typeof window === 'undefined') {\n        return {\n            on: () => { },\n            off: () => { }\n        };\n    }\n    const propagationStopped = new WeakMap();\n    const immediatePropagationStopped = new WeakMap();\n    function trackPropagation() {\n        propagationStopped.set(this, true);\n    }\n    function trackImmediate() {\n        propagationStopped.set(this, true);\n        immediatePropagationStopped.set(this, true);\n    }\n    function spy(event, propName, fn) {\n        const source = event[propName];\n        event[propName] = function () {\n            fn.apply(event, arguments);\n            return source.apply(event, arguments);\n        };\n        return event;\n    }\n    function unspy(event, propName) {\n        event[propName] = Event.prototype[propName];\n    }\n    const currentTargets = new WeakMap();\n    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n    function getCurrentTarget() {\n        var _a;\n        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n    }\n    function defineCurrentTarget(event, getter) {\n        if (currentTargetDescriptor === undefined)\n            return;\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            enumerable: true,\n            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n        });\n    }\n    const phaseToTypeToElToHandlers = {\n        bubble: {},\n        capture: {}\n    };\n    const typeToWindowEventHandlers = {};\n    function createUnifiedHandler() {\n        const delegeteHandler = function (e) {\n            const { type, eventPhase, bubbles } = e;\n            const target = getEventTarget(e);\n            if (eventPhase === 2)\n                return;\n            const phase = eventPhase === 1 ? 'capture' : 'bubble';\n            let cursor = target;\n            const path = [];\n            // collecting bubble path\n            while (true) {\n                if (cursor === null)\n                    cursor = window;\n                path.push(cursor);\n                if (cursor === window) {\n                    break;\n                }\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                cursor = (cursor.parentNode || null);\n            }\n            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n            spy(e, 'stopPropagation', trackPropagation);\n            spy(e, 'stopImmediatePropagation', trackImmediate);\n            defineCurrentTarget(e, getCurrentTarget);\n            if (phase === 'capture') {\n                if (captureElToHandlers === undefined)\n                    return;\n                // capture\n                for (let i = path.length - 1; i >= 0; --i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = captureElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                    if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n                        const bubbleHandlers = bubbleElToHandlers.get(target);\n                        if (bubbleHandlers !== undefined) {\n                            for (const handler of bubbleHandlers) {\n                                if (immediatePropagationStopped.has(e))\n                                    break;\n                                handler(e);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (phase === 'bubble') {\n                if (bubbleElToHandlers === undefined)\n                    return;\n                // bubble\n                for (let i = 0; i < path.length; ++i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = bubbleElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                }\n            }\n            unspy(e, 'stopPropagation');\n            unspy(e, 'stopImmediatePropagation');\n            defineCurrentTarget(e);\n        };\n        delegeteHandler.displayName = 'evtdUnifiedHandler';\n        return delegeteHandler;\n    }\n    function createUnifiedWindowEventHandler() {\n        const delegateHandler = function (e) {\n            const { type, eventPhase } = e;\n            if (eventPhase !== 2)\n                return;\n            const handlers = typeToWindowEventHandlers[type];\n            if (handlers === undefined)\n                return;\n            handlers.forEach((handler) => handler(e));\n        };\n        delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n        return delegateHandler;\n    }\n    const unifiedHandler = createUnifiedHandler();\n    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n    function ensureElToHandlers(phase, type) {\n        const phaseHandlers = phaseToTypeToElToHandlers[phase];\n        if (phaseHandlers[type] === undefined) {\n            phaseHandlers[type] = new Map();\n            window.addEventListener(type, unifiedHandler, phase === 'capture');\n        }\n        return phaseHandlers[type];\n    }\n    function ensureWindowEventHandlers(type) {\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        if (windowEventHandlers === undefined) {\n            typeToWindowEventHandlers[type] = new Set();\n            window.addEventListener(type, unfiendWindowEventHandler);\n        }\n        return typeToWindowEventHandlers[type];\n    }\n    function ensureHandlers(elToHandlers, el) {\n        let elHandlers = elToHandlers.get(el);\n        if (elHandlers === undefined) {\n            elToHandlers.set(el, (elHandlers = new Set()));\n        }\n        return elHandlers;\n    }\n    function handlerExist(el, phase, type, handler) {\n        const elToHandlers = phaseToTypeToElToHandlers[phase][type];\n        // phase ${type} event has handlers\n        if (elToHandlers !== undefined) {\n            const handlers = elToHandlers.get(el);\n            // phase using el with ${type} event has handlers\n            if (handlers !== undefined) {\n                if (handlers.has(handler))\n                    return true;\n            }\n        }\n        return false;\n    }\n    function windowEventHandlerExist(type, handler) {\n        const handlers = typeToWindowEventHandlers[type];\n        if (handlers !== undefined) {\n            if (handlers.has(handler)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function on(type, el, handler, options) {\n        let mergedHandler;\n        if (typeof options === 'object' && options.once === true) {\n            mergedHandler = (e) => {\n                off(type, el, mergedHandler, options);\n                handler(e);\n            };\n        }\n        else {\n            mergedHandler = handler;\n        }\n        const trapped = trapOn(type, el, mergedHandler, options);\n        if (trapped)\n            return;\n        const phase = options === true ||\n            (typeof options === 'object' && options.capture === true)\n            ? 'capture'\n            : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (!handlers.has(mergedHandler))\n            handlers.add(mergedHandler);\n        if (el === window) {\n            const windowEventHandlers = ensureWindowEventHandlers(type);\n            if (!windowEventHandlers.has(mergedHandler)) {\n                windowEventHandlers.add(mergedHandler);\n            }\n        }\n    }\n    function off(type, el, handler, options) {\n        const trapped = trapOff(type, el, handler, options);\n        if (trapped)\n            return;\n        const capture = options === true ||\n            (typeof options === 'object' && options.capture === true);\n        const phase = capture ? 'capture' : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (el === window) {\n            const mirrorPhase = capture ? 'bubble' : 'capture';\n            if (!handlerExist(el, mirrorPhase, type, handler) &&\n                windowEventHandlerExist(type, handler)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const windowEventHandlers = typeToWindowEventHandlers[type];\n                windowEventHandlers.delete(handler);\n                if (windowEventHandlers.size === 0) {\n                    window.removeEventListener(type, unfiendWindowEventHandler);\n                    typeToWindowEventHandlers[type] = undefined;\n                }\n            }\n        }\n        if (handlers.has(handler))\n            handlers.delete(handler);\n        if (handlers.size === 0) {\n            elToHandlers.delete(el);\n        }\n        if (elToHandlers.size === 0) {\n            window.removeEventListener(type, unifiedHandler, phase === 'capture');\n            phaseToTypeToElToHandlers[phase][type] = undefined;\n        }\n    }\n    return {\n        on: on,\n        off: off\n    };\n}\nconst { on, off } = createDelegate();\nexport { on, off };\n"],"mappings":";AAAA,SAASA,MAAT,EAAiBC,OAAjB,QAAgC,SAAhC;AACA,SAASC,cAAT,QAA+B,SAA/B,C,CACA;;AACA,SAASC,cAAT,GAA0B;EACtB,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;IAC/B,OAAO;MACHC,EAAE,EAAE,MAAM,CAAG,CADV;MAEHC,GAAG,EAAE,MAAM,CAAG;IAFX,CAAP;EAIH;;EACD,MAAMC,kBAAkB,GAAG,IAAIC,OAAJ,EAA3B;EACA,MAAMC,2BAA2B,GAAG,IAAID,OAAJ,EAApC;;EACA,SAASE,gBAAT,GAA4B;IACxBH,kBAAkB,CAACI,GAAnB,CAAuB,IAAvB,EAA6B,IAA7B;EACH;;EACD,SAASC,cAAT,GAA0B;IACtBL,kBAAkB,CAACI,GAAnB,CAAuB,IAAvB,EAA6B,IAA7B;IACAF,2BAA2B,CAACE,GAA5B,CAAgC,IAAhC,EAAsC,IAAtC;EACH;;EACD,SAASE,GAAT,CAAaC,KAAb,EAAoBC,QAApB,EAA8BC,EAA9B,EAAkC;IAC9B,MAAMC,MAAM,GAAGH,KAAK,CAACC,QAAD,CAApB;;IACAD,KAAK,CAACC,QAAD,CAAL,GAAkB,YAAY;MAC1BC,EAAE,CAACE,KAAH,CAASJ,KAAT,EAAgBK,SAAhB;MACA,OAAOF,MAAM,CAACC,KAAP,CAAaJ,KAAb,EAAoBK,SAApB,CAAP;IACH,CAHD;;IAIA,OAAOL,KAAP;EACH;;EACD,SAASM,KAAT,CAAeN,KAAf,EAAsBC,QAAtB,EAAgC;IAC5BD,KAAK,CAACC,QAAD,CAAL,GAAkBM,KAAK,CAACC,SAAN,CAAgBP,QAAhB,CAAlB;EACH;;EACD,MAAMQ,cAAc,GAAG,IAAIf,OAAJ,EAAvB;EACA,MAAMgB,uBAAuB,GAAGC,MAAM,CAACC,wBAAP,CAAgCL,KAAK,CAACC,SAAtC,EAAiD,eAAjD,CAAhC;;EACA,SAASK,gBAAT,GAA4B;IACxB,IAAIC,EAAJ;;IACA,OAAO,CAACA,EAAE,GAAGL,cAAc,CAACM,GAAf,CAAmB,IAAnB,CAAN,MAAoC,IAApC,IAA4CD,EAAE,KAAK,KAAK,CAAxD,GAA4DA,EAA5D,GAAiE,IAAxE;EACH;;EACD,SAASE,mBAAT,CAA6BhB,KAA7B,EAAoCiB,MAApC,EAA4C;IACxC,IAAIP,uBAAuB,KAAKQ,SAAhC,EACI;IACJP,MAAM,CAACQ,cAAP,CAAsBnB,KAAtB,EAA6B,eAA7B,EAA8C;MAC1CoB,YAAY,EAAE,IAD4B;MAE1CC,UAAU,EAAE,IAF8B;MAG1CN,GAAG,EAAEE,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuCA,MAAvC,GAAgDP,uBAAuB,CAACK;IAHnC,CAA9C;EAKH;;EACD,MAAMO,yBAAyB,GAAG;IAC9BC,MAAM,EAAE,EADsB;IAE9BC,OAAO,EAAE;EAFqB,CAAlC;EAIA,MAAMC,yBAAyB,GAAG,EAAlC;;EACA,SAASC,oBAAT,GAAgC;IAC5B,MAAMC,eAAe,GAAG,UAAUC,CAAV,EAAa;MACjC,MAAM;QAAEC,IAAF;QAAQC,UAAR;QAAoBC;MAApB,IAAgCH,CAAtC;MACA,MAAMI,MAAM,GAAG5C,cAAc,CAACwC,CAAD,CAA7B;MACA,IAAIE,UAAU,KAAK,CAAnB,EACI;MACJ,MAAMG,KAAK,GAAGH,UAAU,KAAK,CAAf,GAAmB,SAAnB,GAA+B,QAA7C;MACA,IAAII,MAAM,GAAGF,MAAb;MACA,MAAMG,IAAI,GAAG,EAAb,CAPiC,CAQjC;;MACA,OAAO,IAAP,EAAa;QACT,IAAID,MAAM,KAAK,IAAf,EACIA,MAAM,GAAG5C,MAAT;QACJ6C,IAAI,CAACC,IAAL,CAAUF,MAAV;;QACA,IAAIA,MAAM,KAAK5C,MAAf,EAAuB;UACnB;QACH,CANQ,CAOT;;;QACA4C,MAAM,GAAIA,MAAM,CAACG,UAAP,IAAqB,IAA/B;MACH;;MACD,MAAMC,mBAAmB,GAAGhB,yBAAyB,CAACE,OAA1B,CAAkCK,IAAlC,CAA5B;MACA,MAAMU,kBAAkB,GAAGjB,yBAAyB,CAACC,MAA1B,CAAiCM,IAAjC,CAA3B;MACA9B,GAAG,CAAC6B,CAAD,EAAI,iBAAJ,EAAuBhC,gBAAvB,CAAH;MACAG,GAAG,CAAC6B,CAAD,EAAI,0BAAJ,EAAgC9B,cAAhC,CAAH;MACAkB,mBAAmB,CAACY,CAAD,EAAIf,gBAAJ,CAAnB;;MACA,IAAIoB,KAAK,KAAK,SAAd,EAAyB;QACrB,IAAIK,mBAAmB,KAAKpB,SAA5B,EACI,OAFiB,CAGrB;;QACA,KAAK,IAAIsB,CAAC,GAAGL,IAAI,CAACM,MAAL,GAAc,CAA3B,EAA8BD,CAAC,IAAI,CAAnC,EAAsC,EAAEA,CAAxC,EAA2C;UACvC,IAAI/C,kBAAkB,CAACiD,GAAnB,CAAuBd,CAAvB,CAAJ,EACI;UACJ,MAAMI,MAAM,GAAGG,IAAI,CAACK,CAAD,CAAnB;UACA,MAAMG,QAAQ,GAAGL,mBAAmB,CAACvB,GAApB,CAAwBiB,MAAxB,CAAjB;;UACA,IAAIW,QAAQ,KAAKzB,SAAjB,EAA4B;YACxBT,cAAc,CAACZ,GAAf,CAAmB+B,CAAnB,EAAsBI,MAAtB;;YACA,KAAK,MAAMY,OAAX,IAAsBD,QAAtB,EAAgC;cAC5B,IAAIhD,2BAA2B,CAAC+C,GAA5B,CAAgCd,CAAhC,CAAJ,EACI;cACJgB,OAAO,CAAChB,CAAD,CAAP;YACH;UACJ;;UACD,IAAIY,CAAC,KAAK,CAAN,IAAW,CAACT,OAAZ,IAAuBQ,kBAAkB,KAAKrB,SAAlD,EAA6D;YACzD,MAAM2B,cAAc,GAAGN,kBAAkB,CAACxB,GAAnB,CAAuBiB,MAAvB,CAAvB;;YACA,IAAIa,cAAc,KAAK3B,SAAvB,EAAkC;cAC9B,KAAK,MAAM0B,OAAX,IAAsBC,cAAtB,EAAsC;gBAClC,IAAIlD,2BAA2B,CAAC+C,GAA5B,CAAgCd,CAAhC,CAAJ,EACI;gBACJgB,OAAO,CAAChB,CAAD,CAAP;cACH;YACJ;UACJ;QACJ;MACJ,CA5BD,MA6BK,IAAIK,KAAK,KAAK,QAAd,EAAwB;QACzB,IAAIM,kBAAkB,KAAKrB,SAA3B,EACI,OAFqB,CAGzB;;QACA,KAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACM,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;UAClC,IAAI/C,kBAAkB,CAACiD,GAAnB,CAAuBd,CAAvB,CAAJ,EACI;UACJ,MAAMI,MAAM,GAAGG,IAAI,CAACK,CAAD,CAAnB;UACA,MAAMG,QAAQ,GAAGJ,kBAAkB,CAACxB,GAAnB,CAAuBiB,MAAvB,CAAjB;;UACA,IAAIW,QAAQ,KAAKzB,SAAjB,EAA4B;YACxBT,cAAc,CAACZ,GAAf,CAAmB+B,CAAnB,EAAsBI,MAAtB;;YACA,KAAK,MAAMY,OAAX,IAAsBD,QAAtB,EAAgC;cAC5B,IAAIhD,2BAA2B,CAAC+C,GAA5B,CAAgCd,CAAhC,CAAJ,EACI;cACJgB,OAAO,CAAChB,CAAD,CAAP;YACH;UACJ;QACJ;MACJ;;MACDtB,KAAK,CAACsB,CAAD,EAAI,iBAAJ,CAAL;MACAtB,KAAK,CAACsB,CAAD,EAAI,0BAAJ,CAAL;MACAZ,mBAAmB,CAACY,CAAD,CAAnB;IACH,CA3ED;;IA4EAD,eAAe,CAACmB,WAAhB,GAA8B,oBAA9B;IACA,OAAOnB,eAAP;EACH;;EACD,SAASoB,+BAAT,GAA2C;IACvC,MAAMC,eAAe,GAAG,UAAUpB,CAAV,EAAa;MACjC,MAAM;QAAEC,IAAF;QAAQC;MAAR,IAAuBF,CAA7B;MACA,IAAIE,UAAU,KAAK,CAAnB,EACI;MACJ,MAAMa,QAAQ,GAAGlB,yBAAyB,CAACI,IAAD,CAA1C;MACA,IAAIc,QAAQ,KAAKzB,SAAjB,EACI;MACJyB,QAAQ,CAACM,OAAT,CAAkBL,OAAD,IAAaA,OAAO,CAAChB,CAAD,CAArC;IACH,CARD;;IASAoB,eAAe,CAACF,WAAhB,GAA8B,+BAA9B;IACA,OAAOE,eAAP;EACH;;EACD,MAAME,cAAc,GAAGxB,oBAAoB,EAA3C;EACA,MAAMyB,yBAAyB,GAAGJ,+BAA+B,EAAjE;;EACA,SAASK,kBAAT,CAA4BnB,KAA5B,EAAmCJ,IAAnC,EAAyC;IACrC,MAAMwB,aAAa,GAAG/B,yBAAyB,CAACW,KAAD,CAA/C;;IACA,IAAIoB,aAAa,CAACxB,IAAD,CAAb,KAAwBX,SAA5B,EAAuC;MACnCmC,aAAa,CAACxB,IAAD,CAAb,GAAsB,IAAIyB,GAAJ,EAAtB;MACAhE,MAAM,CAACiE,gBAAP,CAAwB1B,IAAxB,EAA8BqB,cAA9B,EAA8CjB,KAAK,KAAK,SAAxD;IACH;;IACD,OAAOoB,aAAa,CAACxB,IAAD,CAApB;EACH;;EACD,SAAS2B,yBAAT,CAAmC3B,IAAnC,EAAyC;IACrC,MAAM4B,mBAAmB,GAAGhC,yBAAyB,CAACI,IAAD,CAArD;;IACA,IAAI4B,mBAAmB,KAAKvC,SAA5B,EAAuC;MACnCO,yBAAyB,CAACI,IAAD,CAAzB,GAAkC,IAAI6B,GAAJ,EAAlC;MACApE,MAAM,CAACiE,gBAAP,CAAwB1B,IAAxB,EAA8BsB,yBAA9B;IACH;;IACD,OAAO1B,yBAAyB,CAACI,IAAD,CAAhC;EACH;;EACD,SAAS8B,cAAT,CAAwBC,YAAxB,EAAsCC,EAAtC,EAA0C;IACtC,IAAIC,UAAU,GAAGF,YAAY,CAAC7C,GAAb,CAAiB8C,EAAjB,CAAjB;;IACA,IAAIC,UAAU,KAAK5C,SAAnB,EAA8B;MAC1B0C,YAAY,CAAC/D,GAAb,CAAiBgE,EAAjB,EAAsBC,UAAU,GAAG,IAAIJ,GAAJ,EAAnC;IACH;;IACD,OAAOI,UAAP;EACH;;EACD,SAASC,YAAT,CAAsBF,EAAtB,EAA0B5B,KAA1B,EAAiCJ,IAAjC,EAAuCe,OAAvC,EAAgD;IAC5C,MAAMgB,YAAY,GAAGtC,yBAAyB,CAACW,KAAD,CAAzB,CAAiCJ,IAAjC,CAArB,CAD4C,CAE5C;;IACA,IAAI+B,YAAY,KAAK1C,SAArB,EAAgC;MAC5B,MAAMyB,QAAQ,GAAGiB,YAAY,CAAC7C,GAAb,CAAiB8C,EAAjB,CAAjB,CAD4B,CAE5B;;MACA,IAAIlB,QAAQ,KAAKzB,SAAjB,EAA4B;QACxB,IAAIyB,QAAQ,CAACD,GAAT,CAAaE,OAAb,CAAJ,EACI,OAAO,IAAP;MACP;IACJ;;IACD,OAAO,KAAP;EACH;;EACD,SAASoB,uBAAT,CAAiCnC,IAAjC,EAAuCe,OAAvC,EAAgD;IAC5C,MAAMD,QAAQ,GAAGlB,yBAAyB,CAACI,IAAD,CAA1C;;IACA,IAAIc,QAAQ,KAAKzB,SAAjB,EAA4B;MACxB,IAAIyB,QAAQ,CAACD,GAAT,CAAaE,OAAb,CAAJ,EAA2B;QACvB,OAAO,IAAP;MACH;IACJ;;IACD,OAAO,KAAP;EACH;;EACD,SAASrD,EAAT,CAAYsC,IAAZ,EAAkBgC,EAAlB,EAAsBjB,OAAtB,EAA+BqB,OAA/B,EAAwC;IACpC,IAAIC,aAAJ;;IACA,IAAI,OAAOD,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACE,IAAR,KAAiB,IAApD,EAA0D;MACtDD,aAAa,GAAItC,CAAD,IAAO;QACnBpC,GAAG,CAACqC,IAAD,EAAOgC,EAAP,EAAWK,aAAX,EAA0BD,OAA1B,CAAH;QACArB,OAAO,CAAChB,CAAD,CAAP;MACH,CAHD;IAIH,CALD,MAMK;MACDsC,aAAa,GAAGtB,OAAhB;IACH;;IACD,MAAMwB,OAAO,GAAGlF,MAAM,CAAC2C,IAAD,EAAOgC,EAAP,EAAWK,aAAX,EAA0BD,OAA1B,CAAtB;IACA,IAAIG,OAAJ,EACI;IACJ,MAAMnC,KAAK,GAAGgC,OAAO,KAAK,IAAZ,IACT,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACzC,OAAR,KAAoB,IAD1C,GAER,SAFQ,GAGR,QAHN;IAIA,MAAMoC,YAAY,GAAGR,kBAAkB,CAACnB,KAAD,EAAQJ,IAAR,CAAvC;IACA,MAAMc,QAAQ,GAAGgB,cAAc,CAACC,YAAD,EAAeC,EAAf,CAA/B;IACA,IAAI,CAAClB,QAAQ,CAACD,GAAT,CAAawB,aAAb,CAAL,EACIvB,QAAQ,CAAC0B,GAAT,CAAaH,aAAb;;IACJ,IAAIL,EAAE,KAAKvE,MAAX,EAAmB;MACf,MAAMmE,mBAAmB,GAAGD,yBAAyB,CAAC3B,IAAD,CAArD;;MACA,IAAI,CAAC4B,mBAAmB,CAACf,GAApB,CAAwBwB,aAAxB,CAAL,EAA6C;QACzCT,mBAAmB,CAACY,GAApB,CAAwBH,aAAxB;MACH;IACJ;EACJ;;EACD,SAAS1E,GAAT,CAAaqC,IAAb,EAAmBgC,EAAnB,EAAuBjB,OAAvB,EAAgCqB,OAAhC,EAAyC;IACrC,MAAMG,OAAO,GAAGjF,OAAO,CAAC0C,IAAD,EAAOgC,EAAP,EAAWjB,OAAX,EAAoBqB,OAApB,CAAvB;IACA,IAAIG,OAAJ,EACI;IACJ,MAAM5C,OAAO,GAAGyC,OAAO,KAAK,IAAZ,IACX,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACzC,OAAR,KAAoB,IADxD;IAEA,MAAMS,KAAK,GAAGT,OAAO,GAAG,SAAH,GAAe,QAApC;IACA,MAAMoC,YAAY,GAAGR,kBAAkB,CAACnB,KAAD,EAAQJ,IAAR,CAAvC;IACA,MAAMc,QAAQ,GAAGgB,cAAc,CAACC,YAAD,EAAeC,EAAf,CAA/B;;IACA,IAAIA,EAAE,KAAKvE,MAAX,EAAmB;MACf,MAAMgF,WAAW,GAAG9C,OAAO,GAAG,QAAH,GAAc,SAAzC;;MACA,IAAI,CAACuC,YAAY,CAACF,EAAD,EAAKS,WAAL,EAAkBzC,IAAlB,EAAwBe,OAAxB,CAAb,IACAoB,uBAAuB,CAACnC,IAAD,EAAOe,OAAP,CAD3B,EAC4C;QACxC;QACA,MAAMa,mBAAmB,GAAGhC,yBAAyB,CAACI,IAAD,CAArD;QACA4B,mBAAmB,CAACc,MAApB,CAA2B3B,OAA3B;;QACA,IAAIa,mBAAmB,CAACe,IAApB,KAA6B,CAAjC,EAAoC;UAChClF,MAAM,CAACmF,mBAAP,CAA2B5C,IAA3B,EAAiCsB,yBAAjC;UACA1B,yBAAyB,CAACI,IAAD,CAAzB,GAAkCX,SAAlC;QACH;MACJ;IACJ;;IACD,IAAIyB,QAAQ,CAACD,GAAT,CAAaE,OAAb,CAAJ,EACID,QAAQ,CAAC4B,MAAT,CAAgB3B,OAAhB;;IACJ,IAAID,QAAQ,CAAC6B,IAAT,KAAkB,CAAtB,EAAyB;MACrBZ,YAAY,CAACW,MAAb,CAAoBV,EAApB;IACH;;IACD,IAAID,YAAY,CAACY,IAAb,KAAsB,CAA1B,EAA6B;MACzBlF,MAAM,CAACmF,mBAAP,CAA2B5C,IAA3B,EAAiCqB,cAAjC,EAAiDjB,KAAK,KAAK,SAA3D;MACAX,yBAAyB,CAACW,KAAD,CAAzB,CAAiCJ,IAAjC,IAAyCX,SAAzC;IACH;EACJ;;EACD,OAAO;IACH3B,EAAE,EAAEA,EADD;IAEHC,GAAG,EAAEA;EAFF,CAAP;AAIH;;AACD,MAAM;EAAED,EAAF;EAAMC;AAAN,IAAcH,cAAc,EAAlC;AACA,SAASE,EAAT,EAAaC,GAAb"},"metadata":{},"sourceType":"module"}