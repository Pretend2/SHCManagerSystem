{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n\n/* eslint-disable no-void */\n\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\nimport { mergeProps, computed, defineComponent, ref, onMounted, h, onActivated, onDeactivated } from 'vue';\nimport { beforeNextFrameOnce, depx, pxfy } from 'seemly';\nimport { useMemo } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport VResizeObserver from '../../resize-observer/src/VResizeObserver';\nimport { c, cssrAnchorMetaName, FinweckTree } from '../../shared';\nimport { ensureMaybeTouch, ensureWheelScale } from './config';\nconst styles = c('.v-vl', {\n  maxHeight: 'inherit',\n  height: '100%',\n  overflow: 'auto',\n  minWidth: '1px' // a zero width container won't be scrollable\n\n}, [c('&:not(.v-vl--show-scrollbar)', {\n  scrollbarWidth: 'none'\n}, [c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {\n  width: 0,\n  height: 0,\n  display: 'none'\n})])]);\nexport default defineComponent({\n  name: 'VirtualList',\n  inheritAttrs: false,\n  props: {\n    showScrollbar: {\n      type: Boolean,\n      default: true\n    },\n    items: {\n      type: Array,\n      default: () => []\n    },\n    // it is suppose to be the min height\n    itemSize: {\n      type: Number,\n      required: true\n    },\n    itemResizable: Boolean,\n    itemsStyle: [String, Object],\n    visibleItemsTag: {\n      type: [String, Object],\n      default: 'div'\n    },\n    visibleItemsProps: Object,\n    ignoreItemResize: Boolean,\n    onScroll: Function,\n    onWheel: Function,\n    onResize: Function,\n    defaultScrollKey: [Number, String],\n    defaultScrollIndex: Number,\n    keyField: {\n      type: String,\n      default: 'key'\n    },\n    // Whether it is a good API?\n    // ResizeObserver + footer & header is not enough.\n    // Too complex for simple case\n    paddingTop: {\n      type: [Number, String],\n      default: 0\n    },\n    paddingBottom: {\n      type: [Number, String],\n      default: 0\n    }\n  },\n\n  setup(props) {\n    const ssrAdapter = useSsrAdapter();\n    styles.mount({\n      id: 'vueuc/virtual-list',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onMounted(() => {\n      const {\n        defaultScrollIndex,\n        defaultScrollKey\n      } = props;\n\n      if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {\n        scrollTo({\n          index: defaultScrollIndex\n        });\n      } else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {\n        scrollTo({\n          key: defaultScrollKey\n        });\n      }\n    });\n    let isDeactivated = false;\n    let activateStateInitialized = false;\n    onActivated(() => {\n      isDeactivated = false;\n\n      if (!activateStateInitialized) {\n        activateStateInitialized = true;\n        return;\n      } // remount\n\n\n      scrollTo({\n        top: scrollTopRef.value,\n        left: scrollLeft\n      });\n    });\n    onDeactivated(() => {\n      isDeactivated = true;\n\n      if (!activateStateInitialized) {\n        activateStateInitialized = true;\n      }\n    });\n    const keyIndexMapRef = computed(() => {\n      const map = new Map();\n      const {\n        keyField\n      } = props;\n      props.items.forEach((item, index) => {\n        map.set(item[keyField], index);\n      });\n      return map;\n    });\n    const listElRef = ref(null);\n    const listHeightRef = ref(undefined);\n    const keyToHeightOffset = new Map();\n    const finweckTreeRef = computed(() => {\n      const {\n        items,\n        itemSize,\n        keyField\n      } = props;\n      const ft = new FinweckTree(items.length, itemSize);\n      items.forEach((item, index) => {\n        const key = item[keyField];\n        const heightOffset = keyToHeightOffset.get(key);\n\n        if (heightOffset !== undefined) {\n          ft.add(index, heightOffset);\n        }\n      });\n      return ft;\n    });\n    const finweckTreeUpdateTrigger = ref(0);\n    let scrollLeft = 0;\n    const scrollTopRef = ref(0);\n    const startIndexRef = useMemo(() => {\n      return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);\n    });\n    const viewportItemsRef = computed(() => {\n      const {\n        value: listHeight\n      } = listHeightRef;\n      if (listHeight === undefined) return [];\n      const {\n        items,\n        itemSize\n      } = props;\n      const startIndex = startIndexRef.value;\n      const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);\n      const viewportItems = [];\n\n      for (let i = startIndex; i <= endIndex; ++i) {\n        viewportItems.push(items[i]);\n      }\n\n      return viewportItems;\n    });\n\n    const scrollTo = (options, y) => {\n      if (typeof options === 'number') {\n        scrollToPosition(options, y, 'auto');\n        return;\n      }\n\n      const {\n        left,\n        top,\n        index,\n        key,\n        position,\n        behavior,\n        debounce = true\n      } = options;\n\n      if (left !== undefined || top !== undefined) {\n        scrollToPosition(left, top, behavior);\n      } else if (index !== undefined) {\n        scrollToIndex(index, behavior, debounce);\n      } else if (key !== undefined) {\n        const toIndex = keyIndexMapRef.value.get(key);\n        if (toIndex !== undefined) scrollToIndex(toIndex, behavior, debounce);\n      } else if (position === 'bottom') {\n        scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);\n      } else if (position === 'top') {\n        scrollToPosition(0, 0, behavior);\n      }\n    };\n\n    let anchorIndex;\n    let anchorTimerId = null;\n\n    function scrollToIndex(index, behavior, debounce) {\n      const {\n        value: ft\n      } = finweckTreeRef;\n      const targetTop = ft.sum(index) + depx(props.paddingTop);\n\n      if (!debounce) {\n        listElRef.value.scrollTo({\n          left: 0,\n          top: targetTop,\n          behavior\n        });\n      } else {\n        anchorIndex = index;\n\n        if (anchorTimerId !== null) {\n          window.clearTimeout(anchorTimerId);\n        }\n\n        anchorTimerId = window.setTimeout(() => {\n          anchorIndex = undefined;\n          anchorTimerId = null;\n        }, 16); // use 0 ms may be ealier than resize callback...\n\n        const {\n          scrollTop,\n          offsetHeight\n        } = listElRef.value;\n\n        if (targetTop > scrollTop) {\n          const itemSize = ft.get(index);\n\n          if (targetTop + itemSize <= scrollTop + offsetHeight) {// do nothing\n          } else {\n            listElRef.value.scrollTo({\n              left: 0,\n              top: targetTop + itemSize - offsetHeight,\n              behavior\n            });\n          }\n        } else {\n          listElRef.value.scrollTo({\n            left: 0,\n            top: targetTop,\n            behavior\n          });\n        }\n      }\n    }\n\n    function scrollToPosition(left, top, behavior) {\n      listElRef.value.scrollTo({\n        left,\n        top,\n        behavior\n      });\n    }\n\n    function handleItemResize(key, entry) {\n      var _a, _b, _c;\n\n      if (isDeactivated) return;\n      if (props.ignoreItemResize) return;\n      if (isHideByVShow(entry.target)) return;\n      const {\n        value: ft\n      } = finweckTreeRef;\n      const index = keyIndexMapRef.value.get(key);\n      const previousHeight = ft.get(index);\n      const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;\n      if (height === previousHeight) return; // height offset based on itemSize\n      // used when rebuild the finweck tree\n\n      const offset = height - props.itemSize;\n\n      if (offset === 0) {\n        keyToHeightOffset.delete(key);\n      } else {\n        keyToHeightOffset.set(key, height - props.itemSize);\n      } // delta height based on finweck tree data\n\n\n      const delta = height - previousHeight;\n      if (delta === 0) return;\n      ft.add(index, delta);\n      const listEl = listElRef.value;\n\n      if (listEl != null) {\n        if (anchorIndex === undefined) {\n          const previousHeightSum = ft.sum(index);\n\n          if (listEl.scrollTop > previousHeightSum) {\n            listEl.scrollBy(0, delta);\n          }\n        } else {\n          if (index < anchorIndex) {\n            listEl.scrollBy(0, delta);\n          } else if (index === anchorIndex) {\n            const previousHeightSum = ft.sum(index);\n\n            if (height + previousHeightSum > // Note, listEl shouldn't have border, nor offsetHeight won't be\n            // correct\n            listEl.scrollTop + listEl.offsetHeight) {\n              listEl.scrollBy(0, delta);\n            }\n          }\n        }\n\n        syncViewport();\n      }\n\n      finweckTreeUpdateTrigger.value++;\n    }\n\n    const mayUseWheel = !ensureMaybeTouch();\n    let wheelCatched = false;\n\n    function handleListScroll(e) {\n      var _a;\n\n      (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n\n      if (!mayUseWheel || !wheelCatched) {\n        syncViewport();\n      }\n    }\n\n    function handleListWheel(e) {\n      var _a;\n\n      (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);\n\n      if (mayUseWheel) {\n        const listEl = listElRef.value;\n\n        if (listEl != null) {\n          if (e.deltaX === 0) {\n            if (listEl.scrollTop === 0 && e.deltaY <= 0) {\n              return;\n            }\n\n            if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {\n              return;\n            }\n          }\n\n          e.preventDefault();\n          listEl.scrollTop += e.deltaY / ensureWheelScale();\n          listEl.scrollLeft += e.deltaX / ensureWheelScale();\n          syncViewport();\n          wheelCatched = true;\n          beforeNextFrameOnce(() => {\n            wheelCatched = false;\n          });\n        }\n      }\n    }\n\n    function handleListResize(entry) {\n      if (isDeactivated) return; // List is HTMLElement\n\n      if (isHideByVShow(entry.target)) return; // If height is same, return\n\n      if (entry.contentRect.height === listHeightRef.value) return;\n      listHeightRef.value = entry.contentRect.height;\n      const {\n        onResize\n      } = props;\n      if (onResize !== undefined) onResize(entry);\n    }\n\n    function syncViewport() {\n      const {\n        value: listEl\n      } = listElRef; // sometime ref el can be null\n      // https://github.com/TuSimple/naive-ui/issues/811\n\n      if (listEl == null) return;\n      scrollTopRef.value = listEl.scrollTop;\n      scrollLeft = listEl.scrollLeft;\n    }\n\n    function isHideByVShow(el) {\n      let cursor = el;\n\n      while (cursor !== null) {\n        if (cursor.style.display === 'none') return true;\n        cursor = cursor.parentElement;\n      }\n\n      return false;\n    }\n\n    return {\n      listHeight: listHeightRef,\n      listStyle: {\n        overflow: 'auto'\n      },\n      keyToIndex: keyIndexMapRef,\n      itemsStyle: computed(() => {\n        const {\n          itemResizable\n        } = props;\n        const height = pxfy(finweckTreeRef.value.sum()); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n        finweckTreeUpdateTrigger.value;\n        return [props.itemsStyle, {\n          boxSizing: 'content-box',\n          height: itemResizable ? '' : height,\n          minHeight: itemResizable ? height : '',\n          paddingTop: pxfy(props.paddingTop),\n          paddingBottom: pxfy(props.paddingBottom)\n        }];\n      }),\n      visibleItemsStyle: computed(() => {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        finweckTreeUpdateTrigger.value;\n        return {\n          transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`\n        };\n      }),\n      viewportItems: viewportItemsRef,\n      listElRef,\n      itemsElRef: ref(null),\n      scrollTo,\n      handleListResize,\n      handleListScroll,\n      handleListWheel,\n      handleItemResize\n    };\n  },\n\n  render() {\n    const {\n      itemResizable,\n      keyField,\n      keyToIndex,\n      visibleItemsTag\n    } = this;\n    return h(VResizeObserver, {\n      onResize: this.handleListResize\n    }, {\n      default: () => {\n        var _a, _b;\n\n        return h('div', mergeProps(this.$attrs, {\n          class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],\n          onScroll: this.handleListScroll,\n          onWheel: this.handleListWheel,\n          ref: 'listElRef'\n        }), [this.items.length !== 0 ? h('div', {\n          ref: 'itemsElRef',\n          class: 'v-vl-items',\n          style: this.itemsStyle\n        }, [h(visibleItemsTag, Object.assign({\n          class: 'v-vl-visible-items',\n          style: this.visibleItemsStyle\n        }, this.visibleItemsProps), {\n          default: () => this.viewportItems.map(item => {\n            const key = item[keyField];\n            const index = keyToIndex.get(key);\n            const itemVNode = this.$slots.default({\n              item,\n              index\n            })[0];\n\n            if (itemResizable) {\n              return h(VResizeObserver, {\n                key,\n                onResize: entry => this.handleItemResize(key, entry)\n              }, {\n                default: () => itemVNode\n              });\n            }\n\n            itemVNode.key = key;\n            return itemVNode;\n          })\n        })]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)]);\n      }\n    });\n  }\n\n});","map":{"version":3,"names":["mergeProps","computed","defineComponent","ref","onMounted","h","onActivated","onDeactivated","beforeNextFrameOnce","depx","pxfy","useMemo","useSsrAdapter","VResizeObserver","c","cssrAnchorMetaName","FinweckTree","ensureMaybeTouch","ensureWheelScale","styles","maxHeight","height","overflow","minWidth","scrollbarWidth","width","display","name","inheritAttrs","props","showScrollbar","type","Boolean","default","items","Array","itemSize","Number","required","itemResizable","itemsStyle","String","Object","visibleItemsTag","visibleItemsProps","ignoreItemResize","onScroll","Function","onWheel","onResize","defaultScrollKey","defaultScrollIndex","keyField","paddingTop","paddingBottom","setup","ssrAdapter","mount","id","head","anchorMetaName","ssr","undefined","scrollTo","index","key","isDeactivated","activateStateInitialized","top","scrollTopRef","value","left","scrollLeft","keyIndexMapRef","map","Map","forEach","item","set","listElRef","listHeightRef","keyToHeightOffset","finweckTreeRef","ft","length","heightOffset","get","add","finweckTreeUpdateTrigger","startIndexRef","Math","max","getBound","viewportItemsRef","listHeight","startIndex","endIndex","min","ceil","viewportItems","i","push","options","y","scrollToPosition","position","behavior","debounce","scrollToIndex","toIndex","MAX_SAFE_INTEGER","anchorIndex","anchorTimerId","targetTop","sum","window","clearTimeout","setTimeout","scrollTop","offsetHeight","handleItemResize","entry","_a","_b","_c","isHideByVShow","target","previousHeight","borderBoxSize","blockSize","contentRect","offset","delete","delta","listEl","previousHeightSum","scrollBy","syncViewport","mayUseWheel","wheelCatched","handleListScroll","e","call","handleListWheel","deltaX","deltaY","scrollHeight","preventDefault","handleListResize","el","cursor","style","parentElement","listStyle","keyToIndex","boxSizing","minHeight","visibleItemsStyle","transform","itemsElRef","render","$attrs","class","assign","itemVNode","$slots","empty"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/vueuc/es/virtual-list/src/VirtualList.js"],"sourcesContent":["/* eslint-disable no-void */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\nimport { mergeProps, computed, defineComponent, ref, onMounted, h, onActivated, onDeactivated } from 'vue';\nimport { beforeNextFrameOnce, depx, pxfy } from 'seemly';\nimport { useMemo } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport VResizeObserver from '../../resize-observer/src/VResizeObserver';\nimport { c, cssrAnchorMetaName, FinweckTree } from '../../shared';\nimport { ensureMaybeTouch, ensureWheelScale } from './config';\nconst styles = c('.v-vl', {\n    maxHeight: 'inherit',\n    height: '100%',\n    overflow: 'auto',\n    minWidth: '1px' // a zero width container won't be scrollable\n}, [\n    c('&:not(.v-vl--show-scrollbar)', {\n        scrollbarWidth: 'none'\n    }, [\n        c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {\n            width: 0,\n            height: 0,\n            display: 'none'\n        })\n    ])\n]);\nexport default defineComponent({\n    name: 'VirtualList',\n    inheritAttrs: false,\n    props: {\n        showScrollbar: {\n            type: Boolean,\n            default: true\n        },\n        items: {\n            type: Array,\n            default: () => []\n        },\n        // it is suppose to be the min height\n        itemSize: {\n            type: Number,\n            required: true\n        },\n        itemResizable: Boolean,\n        itemsStyle: [String, Object],\n        visibleItemsTag: {\n            type: [String, Object],\n            default: 'div'\n        },\n        visibleItemsProps: Object,\n        ignoreItemResize: Boolean,\n        onScroll: Function,\n        onWheel: Function,\n        onResize: Function,\n        defaultScrollKey: [Number, String],\n        defaultScrollIndex: Number,\n        keyField: {\n            type: String,\n            default: 'key'\n        },\n        // Whether it is a good API?\n        // ResizeObserver + footer & header is not enough.\n        // Too complex for simple case\n        paddingTop: {\n            type: [Number, String],\n            default: 0\n        },\n        paddingBottom: {\n            type: [Number, String],\n            default: 0\n        }\n    },\n    setup(props) {\n        const ssrAdapter = useSsrAdapter();\n        styles.mount({\n            id: 'vueuc/virtual-list',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(() => {\n            const { defaultScrollIndex, defaultScrollKey } = props;\n            if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {\n                scrollTo({ index: defaultScrollIndex });\n            }\n            else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {\n                scrollTo({ key: defaultScrollKey });\n            }\n        });\n        let isDeactivated = false;\n        let activateStateInitialized = false;\n        onActivated(() => {\n            isDeactivated = false;\n            if (!activateStateInitialized) {\n                activateStateInitialized = true;\n                return;\n            }\n            // remount\n            scrollTo({ top: scrollTopRef.value, left: scrollLeft });\n        });\n        onDeactivated(() => {\n            isDeactivated = true;\n            if (!activateStateInitialized) {\n                activateStateInitialized = true;\n            }\n        });\n        const keyIndexMapRef = computed(() => {\n            const map = new Map();\n            const { keyField } = props;\n            props.items.forEach((item, index) => {\n                map.set(item[keyField], index);\n            });\n            return map;\n        });\n        const listElRef = ref(null);\n        const listHeightRef = ref(undefined);\n        const keyToHeightOffset = new Map();\n        const finweckTreeRef = computed(() => {\n            const { items, itemSize, keyField } = props;\n            const ft = new FinweckTree(items.length, itemSize);\n            items.forEach((item, index) => {\n                const key = item[keyField];\n                const heightOffset = keyToHeightOffset.get(key);\n                if (heightOffset !== undefined) {\n                    ft.add(index, heightOffset);\n                }\n            });\n            return ft;\n        });\n        const finweckTreeUpdateTrigger = ref(0);\n        let scrollLeft = 0;\n        const scrollTopRef = ref(0);\n        const startIndexRef = useMemo(() => {\n            return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);\n        });\n        const viewportItemsRef = computed(() => {\n            const { value: listHeight } = listHeightRef;\n            if (listHeight === undefined)\n                return [];\n            const { items, itemSize } = props;\n            const startIndex = startIndexRef.value;\n            const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);\n            const viewportItems = [];\n            for (let i = startIndex; i <= endIndex; ++i) {\n                viewportItems.push(items[i]);\n            }\n            return viewportItems;\n        });\n        const scrollTo = (options, y) => {\n            if (typeof options === 'number') {\n                scrollToPosition(options, y, 'auto');\n                return;\n            }\n            const { left, top, index, key, position, behavior, debounce = true } = options;\n            if (left !== undefined || top !== undefined) {\n                scrollToPosition(left, top, behavior);\n            }\n            else if (index !== undefined) {\n                scrollToIndex(index, behavior, debounce);\n            }\n            else if (key !== undefined) {\n                const toIndex = keyIndexMapRef.value.get(key);\n                if (toIndex !== undefined)\n                    scrollToIndex(toIndex, behavior, debounce);\n            }\n            else if (position === 'bottom') {\n                scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);\n            }\n            else if (position === 'top') {\n                scrollToPosition(0, 0, behavior);\n            }\n        };\n        let anchorIndex;\n        let anchorTimerId = null;\n        function scrollToIndex(index, behavior, debounce) {\n            const { value: ft } = finweckTreeRef;\n            const targetTop = ft.sum(index) + depx(props.paddingTop);\n            if (!debounce) {\n                listElRef.value.scrollTo({\n                    left: 0,\n                    top: targetTop,\n                    behavior\n                });\n            }\n            else {\n                anchorIndex = index;\n                if (anchorTimerId !== null) {\n                    window.clearTimeout(anchorTimerId);\n                }\n                anchorTimerId = window.setTimeout(() => {\n                    anchorIndex = undefined;\n                    anchorTimerId = null;\n                }, 16); // use 0 ms may be ealier than resize callback...\n                const { scrollTop, offsetHeight } = listElRef.value;\n                if (targetTop > scrollTop) {\n                    const itemSize = ft.get(index);\n                    if (targetTop + itemSize <= scrollTop + offsetHeight) {\n                        // do nothing\n                    }\n                    else {\n                        listElRef.value.scrollTo({\n                            left: 0,\n                            top: targetTop + itemSize - offsetHeight,\n                            behavior\n                        });\n                    }\n                }\n                else {\n                    listElRef.value.scrollTo({\n                        left: 0,\n                        top: targetTop,\n                        behavior\n                    });\n                }\n            }\n        }\n        function scrollToPosition(left, top, behavior) {\n            listElRef.value.scrollTo({\n                left,\n                top,\n                behavior\n            });\n        }\n        function handleItemResize(key, entry) {\n            var _a, _b, _c;\n            if (isDeactivated)\n                return;\n            if (props.ignoreItemResize)\n                return;\n            if (isHideByVShow(entry.target))\n                return;\n            const { value: ft } = finweckTreeRef;\n            const index = keyIndexMapRef.value.get(key);\n            const previousHeight = ft.get(index);\n            const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;\n            if (height === previousHeight)\n                return;\n            // height offset based on itemSize\n            // used when rebuild the finweck tree\n            const offset = height - props.itemSize;\n            if (offset === 0) {\n                keyToHeightOffset.delete(key);\n            }\n            else {\n                keyToHeightOffset.set(key, height - props.itemSize);\n            }\n            // delta height based on finweck tree data\n            const delta = height - previousHeight;\n            if (delta === 0)\n                return;\n            ft.add(index, delta);\n            const listEl = listElRef.value;\n            if (listEl != null) {\n                if (anchorIndex === undefined) {\n                    const previousHeightSum = ft.sum(index);\n                    if (listEl.scrollTop > previousHeightSum) {\n                        listEl.scrollBy(0, delta);\n                    }\n                }\n                else {\n                    if (index < anchorIndex) {\n                        listEl.scrollBy(0, delta);\n                    }\n                    else if (index === anchorIndex) {\n                        const previousHeightSum = ft.sum(index);\n                        if (height + previousHeightSum >\n                            // Note, listEl shouldn't have border, nor offsetHeight won't be\n                            // correct\n                            listEl.scrollTop + listEl.offsetHeight) {\n                            listEl.scrollBy(0, delta);\n                        }\n                    }\n                }\n                syncViewport();\n            }\n            finweckTreeUpdateTrigger.value++;\n        }\n        const mayUseWheel = !ensureMaybeTouch();\n        let wheelCatched = false;\n        function handleListScroll(e) {\n            var _a;\n            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n            if (!mayUseWheel || !wheelCatched) {\n                syncViewport();\n            }\n        }\n        function handleListWheel(e) {\n            var _a;\n            (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);\n            if (mayUseWheel) {\n                const listEl = listElRef.value;\n                if (listEl != null) {\n                    if (e.deltaX === 0) {\n                        if (listEl.scrollTop === 0 && e.deltaY <= 0) {\n                            return;\n                        }\n                        if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight &&\n                            e.deltaY >= 0) {\n                            return;\n                        }\n                    }\n                    e.preventDefault();\n                    listEl.scrollTop += e.deltaY / ensureWheelScale();\n                    listEl.scrollLeft += e.deltaX / ensureWheelScale();\n                    syncViewport();\n                    wheelCatched = true;\n                    beforeNextFrameOnce(() => {\n                        wheelCatched = false;\n                    });\n                }\n            }\n        }\n        function handleListResize(entry) {\n            if (isDeactivated)\n                return;\n            // List is HTMLElement\n            if (isHideByVShow(entry.target))\n                return;\n            // If height is same, return\n            if (entry.contentRect.height === listHeightRef.value)\n                return;\n            listHeightRef.value = entry.contentRect.height;\n            const { onResize } = props;\n            if (onResize !== undefined)\n                onResize(entry);\n        }\n        function syncViewport() {\n            const { value: listEl } = listElRef;\n            // sometime ref el can be null\n            // https://github.com/TuSimple/naive-ui/issues/811\n            if (listEl == null)\n                return;\n            scrollTopRef.value = listEl.scrollTop;\n            scrollLeft = listEl.scrollLeft;\n        }\n        function isHideByVShow(el) {\n            let cursor = el;\n            while (cursor !== null) {\n                if (cursor.style.display === 'none')\n                    return true;\n                cursor = cursor.parentElement;\n            }\n            return false;\n        }\n        return {\n            listHeight: listHeightRef,\n            listStyle: {\n                overflow: 'auto'\n            },\n            keyToIndex: keyIndexMapRef,\n            itemsStyle: computed(() => {\n                const { itemResizable } = props;\n                const height = pxfy(finweckTreeRef.value.sum());\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                finweckTreeUpdateTrigger.value;\n                return [\n                    props.itemsStyle,\n                    {\n                        boxSizing: 'content-box',\n                        height: itemResizable ? '' : height,\n                        minHeight: itemResizable ? height : '',\n                        paddingTop: pxfy(props.paddingTop),\n                        paddingBottom: pxfy(props.paddingBottom)\n                    }\n                ];\n            }),\n            visibleItemsStyle: computed(() => {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                finweckTreeUpdateTrigger.value;\n                return {\n                    transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`\n                };\n            }),\n            viewportItems: viewportItemsRef,\n            listElRef,\n            itemsElRef: ref(null),\n            scrollTo,\n            handleListResize,\n            handleListScroll,\n            handleListWheel,\n            handleItemResize\n        };\n    },\n    render() {\n        const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;\n        return h(VResizeObserver, {\n            onResize: this.handleListResize\n        }, {\n            default: () => {\n                var _a, _b;\n                return h('div', mergeProps(this.$attrs, {\n                    class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],\n                    onScroll: this.handleListScroll,\n                    onWheel: this.handleListWheel,\n                    ref: 'listElRef'\n                }), [\n                    this.items.length !== 0\n                        ? h('div', {\n                            ref: 'itemsElRef',\n                            class: 'v-vl-items',\n                            style: this.itemsStyle\n                        }, [\n                            h(visibleItemsTag, Object.assign({\n                                class: 'v-vl-visible-items',\n                                style: this.visibleItemsStyle\n                            }, this.visibleItemsProps), {\n                                default: () => this.viewportItems.map((item) => {\n                                    const key = item[keyField];\n                                    const index = keyToIndex.get(key);\n                                    const itemVNode = this.$slots.default({\n                                        item,\n                                        index\n                                    })[0];\n                                    if (itemResizable) {\n                                        return h(VResizeObserver, {\n                                            key,\n                                            onResize: (entry) => this.handleItemResize(key, entry)\n                                        }, {\n                                            default: () => itemVNode\n                                        });\n                                    }\n                                    itemVNode.key = key;\n                                    return itemVNode;\n                                })\n                            })\n                        ])\n                        : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)\n                ]);\n            }\n        });\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}