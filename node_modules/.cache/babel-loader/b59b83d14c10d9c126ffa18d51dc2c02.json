{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue'; // injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\n\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n  var _a;\n\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n  watch(registerKeyRef, registerInstance);\n  registerInstance(registerKeyRef.value);\n  onBeforeUnmount(() => {\n    registerInstance(undefined, registerKeyRef.value);\n  });\n\n  function registerInstance(key, oldKey) {\n    const collection = injection[collectionKey];\n    if (oldKey !== undefined) removeInstance(collection, oldKey);\n    if (key !== undefined) addInstance(collection, key);\n  }\n\n  function removeInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    collection[key].splice(collection[key].findIndex(instance => instance === vm), 1);\n  }\n\n  function addInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n\n    if (!~collection[key].findIndex(instance => instance === vm)) {\n      collection[key].push(vm);\n    }\n  }\n} // injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\n\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n\n  injection[collectionKey].push(valueRef.value);\n  watch(valueRef, (value, prevValue) => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === prevValue);\n    if (~index) collectionArray.splice(index, 1);\n    collectionArray.push(value);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === valueRef.value);\n    if (~index) collectionArray.splice(index, 1);\n  });\n} // injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\n\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n\n  onMounted(() => {\n    const el = getElement();\n    if (!el) return;\n    injection[collectionKey].push(el);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const element = getElement();\n    const index = collectionArray.findIndex(collectionElement => collectionElement === element);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}","map":{"version":3,"names":["watch","onMounted","inject","getCurrentInstance","onBeforeUnmount","useInjectionInstanceCollection","injectionName","collectionKey","registerKeyRef","_a","injection","vm","proxy","registerInstance","value","undefined","key","oldKey","collection","removeInstance","addInstance","splice","findIndex","instance","push","useInjectionCollection","valueRef","prevValue","collectionArray","index","collectionValue","useInjectionElementCollection","getElement","el","element","collectionElement"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/naive-ui/es/_utils/composable/use-collection.js"],"sourcesContent":["import { watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue';\n// injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n    var _a;\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n    watch(registerKeyRef, registerInstance);\n    registerInstance(registerKeyRef.value);\n    onBeforeUnmount(() => {\n        registerInstance(undefined, registerKeyRef.value);\n    });\n    function registerInstance(key, oldKey) {\n        const collection = injection[collectionKey];\n        if (oldKey !== undefined)\n            removeInstance(collection, oldKey);\n        if (key !== undefined)\n            addInstance(collection, key);\n    }\n    function removeInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);\n    }\n    function addInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        if (!~collection[key].findIndex((instance) => instance === vm)) {\n            collection[key].push(vm);\n        }\n    }\n}\n// injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    injection[collectionKey].push(valueRef.value);\n    watch(valueRef, (value, prevValue) => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);\n        if (~index)\n            collectionArray.splice(index, 1);\n        collectionArray.push(value);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\n// injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    onMounted(() => {\n        const el = getElement();\n        if (!el)\n            return;\n        injection[collectionKey].push(el);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const element = getElement();\n        const index = collectionArray.findIndex((collectionElement) => collectionElement === element);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}