{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from '../../_utils';\nimport { tabsLight } from '../styles';\nimport { tabsInjectionKey } from './interface';\nimport Tab from './Tab';\nimport style from './styles/index.cssr';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), {\n  value: [String, Number],\n  defaultValue: [String, Number],\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  type: {\n    type: String,\n    default: 'bar'\n  },\n  closable: Boolean,\n  justifyContent: String,\n  size: {\n    type: String,\n    default: 'medium'\n  },\n  tabStyle: [String, Object],\n  barWidth: Number,\n  paneClass: String,\n  paneStyle: [String, Object],\n  addable: [Boolean, Object],\n  tabsPadding: {\n    type: Number,\n    default: 0\n  },\n  animated: Boolean,\n  onBeforeLeave: Function,\n  onAdd: Function,\n  'onUpdate:value': [Function, Array],\n  onUpdateValue: [Function, Array],\n  onClose: [Function, Array],\n  // deprecated\n  labelSize: String,\n  activeName: [String, Number],\n  onActiveNameChange: [Function, Array]\n});\nexport default defineComponent({\n  name: 'Tabs',\n  props: tabsProps,\n\n  setup(props, {\n    slots\n  }) {\n    var _a, _b, _c, _d;\n\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.labelSize !== undefined) {\n          warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n        }\n\n        if (props.activeName !== undefined) {\n          warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n        }\n\n        if (props.onActiveNameChange !== undefined) {\n          warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n        }\n      });\n    }\n\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n    const tabsElRef = ref(null);\n    const barElRef = ref(null);\n    const scrollWrapperElRef = ref(null);\n    const addTabInstRef = ref(null);\n    const xScrollInstRef = ref(null);\n    const leftReachedRef = ref(true);\n    const rightReachedRef = ref(true);\n    const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n    const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n    const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);\n    const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n    const tabChangeIdRef = {\n      id: 0\n    };\n    const tabWrapperStyleRef = computed(() => {\n      if (!props.justifyContent || props.type === 'card') return undefined;\n      return {\n        display: 'flex',\n        justifyContent: props.justifyContent\n      };\n    });\n    watch(mergedValueRef, () => {\n      tabChangeIdRef.id = 0;\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n\n    function getCurrentEl() {\n      var _a;\n\n      const {\n        value\n      } = mergedValueRef;\n      if (value === null) return null;\n      const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n      return tabEl;\n    }\n\n    function updateBarStyle(tabEl) {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n\n      if (tabEl) {\n        const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n        const {\n          barWidth\n        } = props;\n\n        if (tabEl.dataset.disabled === 'true') {\n          barEl.classList.add(disabledClassName);\n        } else {\n          barEl.classList.remove(disabledClassName);\n        }\n\n        if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n          const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n          barEl.style.left = `${offsetDiffLeft}px`;\n          barEl.style.maxWidth = `${barWidth}px`;\n        } else {\n          barEl.style.left = `${tabEl.offsetLeft}px`;\n          barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n        }\n\n        barEl.style.width = '8192px';\n        void barEl.offsetWidth;\n      }\n    }\n\n    function updateCurrentBarStyle() {\n      if (props.type === 'card') return;\n      const tabEl = getCurrentEl();\n\n      if (tabEl) {\n        updateBarStyle(tabEl);\n      }\n    }\n\n    function updateCurrentScrollPosition(smooth) {\n      var _a;\n\n      const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n      if (!scrollWrapperEl) return;\n      const tabEl = getCurrentEl();\n      if (!tabEl) return;\n      const {\n        scrollLeft: scrollWrapperElScrollLeft,\n        offsetWidth: scrollWrapperElOffsetWidth\n      } = scrollWrapperEl;\n      const {\n        offsetLeft: tabElOffsetLeft,\n        offsetWidth: tabElOffsetWidth\n      } = tabEl;\n\n      if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft,\n          behavior: 'smooth'\n        });\n      } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n          behavior: 'smooth'\n        });\n      }\n    }\n\n    const tabsPaneWrapperRef = ref(null);\n    let fromHeight = 0;\n    let hangingTransition = null;\n\n    function onAnimationBeforeLeave(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n\n      if (tabsPaneWrapperEl) {\n        fromHeight = el.getBoundingClientRect().height;\n        const fromHeightPx = `${fromHeight}px`;\n\n        const applyFromStyle = () => {\n          tabsPaneWrapperEl.style.height = fromHeightPx;\n          tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n        };\n\n        if (!hangingTransition) {\n          hangingTransition = applyFromStyle;\n        } else {\n          applyFromStyle();\n          hangingTransition();\n          hangingTransition = null;\n        }\n      }\n    }\n\n    function onAnimationEnter(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n\n      if (tabsPaneWrapperEl) {\n        const targetHeight = el.getBoundingClientRect().height;\n\n        const applyTargetStyle = () => {\n          void document.body.offsetHeight;\n          tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n          tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n        };\n\n        if (!hangingTransition) {\n          hangingTransition = applyTargetStyle;\n        } else {\n          hangingTransition();\n          hangingTransition = null;\n          applyTargetStyle();\n        }\n      }\n    }\n\n    function onAnimationAfterEnter() {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n\n      if (tabsPaneWrapperEl) {\n        tabsPaneWrapperEl.style.maxHeight = '';\n        tabsPaneWrapperEl.style.height = '';\n      }\n    }\n\n    const renderNameListRef = {\n      value: []\n    };\n    const animationDirectionRef = ref('next');\n\n    function activateTab(panelName) {\n      const currentValue = mergedValueRef.value;\n      let dir = 'next';\n\n      for (const name of renderNameListRef.value) {\n        if (name === currentValue) {\n          break;\n        }\n\n        if (name === panelName) {\n          dir = 'prev';\n          break;\n        }\n      }\n\n      animationDirectionRef.value = dir;\n      doUpdateValue(panelName);\n    }\n\n    function doUpdateValue(panelName) {\n      const {\n        onActiveNameChange,\n        onUpdateValue,\n        'onUpdate:value': _onUpdateValue\n      } = props;\n\n      if (onActiveNameChange) {\n        call(onActiveNameChange, panelName);\n      }\n\n      if (onUpdateValue) call(onUpdateValue, panelName);\n      if (_onUpdateValue) call(_onUpdateValue, panelName);\n      uncontrolledValueRef.value = panelName;\n    }\n\n    function handleClose(panelName) {\n      const {\n        onClose\n      } = props;\n      if (onClose) call(onClose, panelName);\n    }\n\n    let firstTimeUpdatePosition = true;\n\n    function updateBarPositionInstantly() {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      if (!firstTimeUpdatePosition) firstTimeUpdatePosition = false;\n      const disableTransitionClassName = 'transition-disabled';\n      barEl.classList.add(disableTransitionClassName);\n      updateCurrentBarStyle(); // here we don't need to force layout after update bar style\n      // since deriveScrollShadow will force layout\n\n      barEl.classList.remove(disableTransitionClassName);\n    }\n\n    let memorizedWidth = 0;\n\n    function _handleNavResize(entry) {\n      var _a, _b;\n\n      if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n        return;\n      }\n\n      if (memorizedWidth === entry.contentRect.width) {\n        return;\n      }\n\n      memorizedWidth = entry.contentRect.width;\n      const {\n        type\n      } = props;\n\n      if (type === 'line' || type === 'bar') {\n        if (firstTimeUpdatePosition || ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n          updateBarPositionInstantly();\n        }\n      }\n\n      if (type !== 'segment') {\n        deriveScrollShadow((_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el);\n      }\n    }\n\n    const handleNavResize = throttle(_handleNavResize, 64);\n    watch([() => props.justifyContent, () => props.size], () => {\n      void nextTick(() => {\n        const {\n          type\n        } = props;\n\n        if (type === 'line' || type === 'bar') {\n          updateBarPositionInstantly();\n        }\n      });\n    });\n    const addTabFixedRef = ref(false);\n\n    function _handleTabsResize(entry) {\n      var _a;\n\n      const {\n        target,\n        contentRect: {\n          width\n        }\n      } = entry; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const containerWidth = target.parentElement.offsetWidth;\n\n      if (!addTabFixedRef.value) {\n        if (containerWidth < width) {\n          addTabFixedRef.value = true;\n        }\n      } else {\n        const {\n          value: addTabInst\n        } = addTabInstRef;\n        if (!addTabInst) return;\n\n        if (containerWidth - width > addTabInst.$el.offsetWidth) {\n          addTabFixedRef.value = false;\n        }\n      }\n\n      deriveScrollShadow((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el);\n    }\n\n    const handleTabsResize = throttle(_handleTabsResize, 64);\n\n    function handleAdd() {\n      const {\n        onAdd\n      } = props;\n      if (onAdd) onAdd();\n      void nextTick(() => {\n        const currentEl = getCurrentEl();\n        const {\n          value: xScrollInst\n        } = xScrollInstRef;\n        if (!currentEl || !xScrollInst) return;\n        xScrollInst.scrollTo({\n          left: currentEl.offsetLeft,\n          top: 0,\n          behavior: 'smooth'\n        });\n      });\n    }\n\n    function deriveScrollShadow(el) {\n      if (!el) return;\n      const {\n        scrollLeft,\n        scrollWidth,\n        offsetWidth\n      } = el;\n      leftReachedRef.value = scrollLeft <= 0;\n      rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n    }\n\n    const handleScroll = throttle(e => {\n      deriveScrollShadow(e.target);\n    }, 64);\n    provide(tabsInjectionKey, {\n      triggerRef: toRef(props, 'trigger'),\n      tabStyleRef: toRef(props, 'tabStyle'),\n      paneClassRef: toRef(props, 'paneClass'),\n      paneStyleRef: toRef(props, 'paneStyle'),\n      mergedClsPrefixRef,\n      typeRef: toRef(props, 'type'),\n      closableRef: toRef(props, 'closable'),\n      valueRef: mergedValueRef,\n      tabChangeIdRef,\n      onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n      activateTab,\n      handleClose,\n      handleAdd\n    });\n    onFontsReady(() => {\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    }); // avoid useless rerender\n\n    watchEffect(() => {\n      const {\n        value: el\n      } = scrollWrapperElRef;\n      if (!el) return;\n      const {\n        value: clsPrefix\n      } = mergedClsPrefixRef;\n      const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;\n      const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;\n\n      if (leftReachedRef.value) {\n        el.classList.remove(shadowBeforeClass);\n      } else {\n        el.classList.add(shadowBeforeClass);\n      }\n\n      if (rightReachedRef.value) {\n        el.classList.remove(shadowAfterClass);\n      } else {\n        el.classList.add(shadowAfterClass);\n      }\n    });\n    const tabsRailElRef = ref(null);\n    watch(mergedValueRef, () => {\n      if (props.type === 'segment') {\n        const tabsRailEl = tabsRailElRef.value;\n\n        if (tabsRailEl) {\n          void nextTick(() => {\n            tabsRailEl.classList.add('transition-disabled');\n            void tabsRailEl.offsetWidth;\n            tabsRailEl.classList.remove('transition-disabled');\n          });\n        }\n      }\n    });\n    const exposedMethods = {\n      syncBarPosition: () => {\n        updateCurrentBarStyle();\n      }\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        value: size\n      } = compitableSizeRef;\n      const {\n        type\n      } = props;\n      const typeSuffix = {\n        card: 'Card',\n        bar: 'Bar',\n        line: 'Line',\n        segment: 'Segment'\n      }[type];\n      const sizeType = `${size}${typeSuffix}`;\n      const {\n        self: {\n          barColor,\n          closeIconColor,\n          closeIconColorHover,\n          closeIconColorPressed,\n          tabColor,\n          tabBorderColor,\n          paneTextColor,\n          tabFontWeight,\n          tabBorderRadius,\n          tabFontWeightActive,\n          colorSegment,\n          fontWeightStrong,\n          tabColorSegment,\n          closeSize,\n          closeIconSize,\n          closeColorHover,\n          closeColorPressed,\n          closeBorderRadius,\n          [createKey('panePadding', size)]: panePadding,\n          [createKey('tabPadding', sizeType)]: tabPadding,\n          [createKey('tabGap', sizeType)]: tabGap,\n          [createKey('tabTextColor', type)]: tabTextColor,\n          [createKey('tabTextColorActive', type)]: tabTextColorActive,\n          [createKey('tabTextColorHover', type)]: tabTextColorHover,\n          [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled,\n          [createKey('tabFontSize', size)]: tabFontSize\n        },\n        common: {\n          cubicBezierEaseInOut\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-color-segment': colorSegment,\n        '--n-bar-color': barColor,\n        '--n-tab-font-size': tabFontSize,\n        '--n-tab-text-color': tabTextColor,\n        '--n-tab-text-color-active': tabTextColorActive,\n        '--n-tab-text-color-disabled': tabTextColorDisabled,\n        '--n-tab-text-color-hover': tabTextColorHover,\n        '--n-pane-text-color': paneTextColor,\n        '--n-tab-border-color': tabBorderColor,\n        '--n-tab-border-radius': tabBorderRadius,\n        '--n-close-size': closeSize,\n        '--n-close-icon-size': closeIconSize,\n        '--n-close-color-hover': closeColorHover,\n        '--n-close-color-pressed': closeColorPressed,\n        '--n-close-border-radius': closeBorderRadius,\n        '--n-close-icon-color': closeIconColor,\n        '--n-close-icon-color-hover': closeIconColorHover,\n        '--n-close-icon-color-pressed': closeIconColorPressed,\n        '--n-tab-color': tabColor,\n        '--n-tab-font-weight': tabFontWeight,\n        '--n-tab-font-weight-active': tabFontWeightActive,\n        '--n-tab-padding': tabPadding,\n        '--n-tab-gap': tabGap,\n        '--n-pane-padding': panePadding,\n        '--n-font-weight-strong': fontWeightStrong,\n        '--n-tab-color-segment': tabColorSegment\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tabs', computed(() => {\n      return `${compitableSizeRef.value[0]}${props.type[0]}`;\n    }), cssVarsRef, props) : undefined;\n    return Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedValue: mergedValueRef,\n      renderedNames: new Set(),\n      tabsRailElRef,\n      tabsPaneWrapperRef,\n      tabsElRef,\n      barElRef,\n      addTabInstRef,\n      xScrollInstRef,\n      scrollWrapperElRef,\n      addTabFixed: addTabFixedRef,\n      tabWrapperStyle: tabWrapperStyleRef,\n      handleNavResize,\n      mergedSize: compitableSizeRef,\n      handleScroll,\n      handleTabsResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      animationDirection: animationDirectionRef,\n      renderNameListRef,\n      onAnimationBeforeLeave,\n      onAnimationEnter,\n      onAnimationAfterEnter,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    }, exposedMethods);\n  },\n\n  render() {\n    const {\n      mergedClsPrefix,\n      type,\n      addTabFixed,\n      addable,\n      mergedSize,\n      renderNameListRef,\n      onRender,\n      $slots: {\n        default: defaultSlot,\n        prefix: prefixSlot,\n        suffix: suffixSlot\n      }\n    } = this;\n    onRender === null || onRender === void 0 ? void 0 : onRender();\n    const tabPaneChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB_PANE__ === true;\n    }) : [];\n    const tabChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB__ === true;\n    }) : [];\n    const showPane = !tabChildren.length;\n    const isCard = type === 'card';\n    const isSegment = type === 'segment';\n    const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n    renderNameListRef.value = [];\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`],\n      style: this.cssVars\n    }, h(\"div\", {\n      class: [// the class should be applied here since it's possible\n      // to make tabs nested in tabs, style may influence each\n      // other. adding a class will make it easy to write the\n      // style.\n      `${mergedClsPrefix}-tabs-nav--${type}-type`, `${mergedClsPrefix}-tabs-nav`]\n    }, resolveWrappedSlot(prefixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__prefix`\n    }, children)), isSegment ? h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-rail`,\n      ref: \"tabsRailElRef\"\n    }, showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n      renderNameListRef.value.push(tabPaneVNode.props.name);\n      return h(Tab, Object.assign({}, tabPaneVNode.props, {\n        internalCreatedByPane: true,\n        internalLeftPadded: index !== 0\n      }), tabPaneVNode.children ? {\n        default: tabPaneVNode.children.tab\n      } : undefined);\n    }) : tabChildren.map((tabVNode, index) => {\n      renderNameListRef.value.push(tabVNode.props.name);\n\n      if (index === 0) {\n        return tabVNode;\n      } else {\n        return createLeftPaddedTabVNode(tabVNode);\n      }\n    })) : h(VResizeObserver, {\n      onResize: this.handleNavResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,\n        ref: \"scrollWrapperElRef\"\n      }, h(VXScroll, {\n        ref: \"xScrollInstRef\",\n        onScroll: this.handleScroll\n      }, {\n        default: () => {\n          const rawWrappedTabs = h(\"div\", {\n            style: this.tabWrapperStyle,\n            class: `${mergedClsPrefix}-tabs-wrapper`\n          }, mergedJustifyContent ? null : h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-scroll-padding`,\n            style: {\n              width: `${this.tabsPadding}px`\n            }\n          }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n            renderNameListRef.value.push(tabPaneVNode.props.name);\n            return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, {\n              internalCreatedByPane: true,\n              internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === 'center' || mergedJustifyContent === 'start' || mergedJustifyContent === 'end')\n            }), tabPaneVNode.children ? {\n              default: tabPaneVNode.children.tab\n            } : undefined));\n          }) : tabChildren.map((tabVNode, index) => {\n            renderNameListRef.value.push(tabVNode.props.name);\n\n            if (index !== 0 && !mergedJustifyContent) {\n              return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n            } else {\n              return justifyTabDynamicProps(tabVNode);\n            }\n          }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-scroll-padding`,\n            style: {\n              width: `${this.tabsPadding}px`\n            }\n          }));\n          let wrappedTabs = rawWrappedTabs;\n\n          if (isCard && addable) {\n            wrappedTabs = h(VResizeObserver, {\n              onResize: this.handleTabsResize\n            }, {\n              default: () => rawWrappedTabs\n            });\n          }\n\n          return h(\"div\", {\n            ref: \"tabsElRef\",\n            class: `${mergedClsPrefix}-tabs-nav-scroll-content`\n          }, wrappedTabs, isCard ? h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-pad`\n          }) : null, isCard ? null : h(\"div\", {\n            ref: \"barElRef\",\n            class: `${mergedClsPrefix}-tabs-bar`\n          }));\n        }\n      }))\n    }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__suffix`\n    }, children))), showPane && (this.animated ? h(\"div\", {\n      ref: \"tabsPaneWrapperRef\",\n      class: `${mergedClsPrefix}-tabs-pane-wrapper`\n    }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));\n  }\n\n});\n\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n  const children = [];\n  tabPaneVNodes.forEach(vNode => {\n    const {\n      name,\n      displayDirective,\n      'display-directive': _displayDirective\n    } = vNode.props;\n\n    const matchDisplayDirective = directive => displayDirective === directive || _displayDirective === directive;\n\n    const show = value === name;\n\n    if (vNode.key !== undefined) {\n      vNode.key = name;\n    }\n\n    if (show || matchDisplayDirective('show') || matchDisplayDirective('show:lazy') && renderedNames.has(name)) {\n      if (!renderedNames.has(name)) {\n        renderedNames.add(name);\n      }\n\n      const useVShow = !matchDisplayDirective('if');\n      children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n    }\n  });\n\n  if (!animationDirection) {\n    return children;\n  }\n\n  return h(TransitionGroup, {\n    name: `${animationDirection}-transition`,\n    onBeforeLeave: onBeforeLeave,\n    onEnter: onEnter,\n    onAfterEnter: onAfterEnter\n  }, {\n    default: () => children\n  });\n}\n\nfunction createAddTag(addable, internalLeftPadded) {\n  return h(Tab, {\n    ref: \"addTabInstRef\",\n    key: \"__addable\",\n    name: \"__addable\",\n    internalCreatedByPane: true,\n    internalAddable: true,\n    internalLeftPadded: internalLeftPadded,\n    disabled: typeof addable === 'object' && addable.disabled\n  });\n}\n\nfunction createLeftPaddedTabVNode(tabVNode) {\n  const modifiedVNode = cloneVNode(tabVNode);\n\n  if (modifiedVNode.props) {\n    modifiedVNode.props.internalLeftPadded = true;\n  } else {\n    modifiedVNode.props = {\n      internalLeftPadded: true\n    };\n  }\n\n  return modifiedVNode;\n}\n\nfunction justifyTabDynamicProps(tabVNode) {\n  if (Array.isArray(tabVNode.dynamicProps)) {\n    if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n      tabVNode.dynamicProps.push('internalLeftPadded');\n    }\n  } else {\n    tabVNode.dynamicProps = ['internalLeftPadded'];\n  }\n\n  return tabVNode;\n}","map":{"version":3,"names":["h","ref","defineComponent","computed","provide","watch","toRef","nextTick","withDirectives","vShow","watchEffect","cloneVNode","TransitionGroup","VResizeObserver","VXScroll","throttle","useCompitable","onFontsReady","useMergedState","useConfig","useTheme","useThemeClass","createKey","call","flatten","warnOnce","resolveWrappedSlot","tabsLight","tabsInjectionKey","Tab","style","tabsProps","Object","assign","props","value","String","Number","defaultValue","trigger","type","default","closable","Boolean","justifyContent","size","tabStyle","barWidth","paneClass","paneStyle","addable","tabsPadding","animated","onBeforeLeave","Function","onAdd","Array","onUpdateValue","onClose","labelSize","activeName","onActiveNameChange","name","setup","slots","_a","_b","_c","_d","process","env","NODE_ENV","undefined","mergedClsPrefixRef","inlineThemeDisabled","themeRef","tabsElRef","barElRef","scrollWrapperElRef","addTabInstRef","xScrollInstRef","leftReachedRef","rightReachedRef","compitableSizeRef","compitableValueRef","uncontrolledValueRef","mergedValueRef","tabChangeIdRef","id","tabWrapperStyleRef","display","updateCurrentBarStyle","updateCurrentScrollPosition","getCurrentEl","tabEl","querySelector","updateBarStyle","barEl","disabledClassName","dataset","disabled","classList","add","remove","offsetWidth","offsetDiffLeft","Math","floor","offsetLeft","left","maxWidth","width","smooth","scrollWrapperEl","$el","scrollLeft","scrollWrapperElScrollLeft","scrollWrapperElOffsetWidth","tabElOffsetLeft","tabElOffsetWidth","scrollTo","top","behavior","tabsPaneWrapperRef","fromHeight","hangingTransition","onAnimationBeforeLeave","el","tabsPaneWrapperEl","getBoundingClientRect","height","fromHeightPx","applyFromStyle","maxHeight","onAnimationEnter","targetHeight","applyTargetStyle","document","body","offsetHeight","max","onAnimationAfterEnter","renderNameListRef","animationDirectionRef","activateTab","panelName","currentValue","dir","doUpdateValue","_onUpdateValue","handleClose","firstTimeUpdatePosition","updateBarPositionInstantly","disableTransitionClassName","memorizedWidth","_handleNavResize","entry","contentRect","startsWith","deriveScrollShadow","handleNavResize","addTabFixedRef","_handleTabsResize","target","containerWidth","parentElement","addTabInst","handleTabsResize","handleAdd","currentEl","xScrollInst","scrollWidth","handleScroll","e","triggerRef","tabStyleRef","paneClassRef","paneStyleRef","typeRef","closableRef","valueRef","onBeforeLeaveRef","clsPrefix","shadowBeforeClass","shadowAfterClass","tabsRailElRef","tabsRailEl","exposedMethods","syncBarPosition","cssVarsRef","typeSuffix","card","bar","line","segment","sizeType","self","barColor","closeIconColor","closeIconColorHover","closeIconColorPressed","tabColor","tabBorderColor","paneTextColor","tabFontWeight","tabBorderRadius","tabFontWeightActive","colorSegment","fontWeightStrong","tabColorSegment","closeSize","closeIconSize","closeColorHover","closeColorPressed","closeBorderRadius","panePadding","tabPadding","tabGap","tabTextColor","tabTextColorActive","tabTextColorHover","tabTextColorDisabled","tabFontSize","common","cubicBezierEaseInOut","themeClassHandle","mergedClsPrefix","mergedValue","renderedNames","Set","addTabFixed","tabWrapperStyle","mergedSize","cssVars","themeClass","animationDirection","onRender","render","$slots","defaultSlot","prefix","prefixSlot","suffix","suffixSlot","tabPaneChildren","filter","v","__TAB_PANE__","tabChildren","__TAB__","showPane","length","isCard","isSegment","mergedJustifyContent","class","children","map","tabPaneVNode","index","push","internalCreatedByPane","internalLeftPadded","tab","tabVNode","createLeftPaddedTabVNode","onResize","onScroll","rawWrappedTabs","justifyTabDynamicProps","createAddTag","wrappedTabs","filterMapTabPanes","tabPaneVNodes","onEnter","onAfterEnter","forEach","vNode","displayDirective","_displayDirective","matchDisplayDirective","directive","show","key","has","useVShow","internalAddable","modifiedVNode","isArray","dynamicProps","includes"],"sources":["D:/VCode/SHC社区管理系统/shc_community_manager_system/node_modules/naive-ui/es/tabs/src/Tabs.js"],"sourcesContent":["import { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from '../../_utils';\nimport { tabsLight } from '../styles';\nimport { tabsInjectionKey } from './interface';\nimport Tab from './Tab';\nimport style from './styles/index.cssr';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), { value: [String, Number], defaultValue: [String, Number], trigger: {\n        type: String,\n        default: 'click'\n    }, type: {\n        type: String,\n        default: 'bar'\n    }, closable: Boolean, justifyContent: String, size: {\n        type: String,\n        default: 'medium'\n    }, tabStyle: [String, Object], barWidth: Number, paneClass: String, paneStyle: [String, Object], addable: [Boolean, Object], tabsPadding: {\n        type: Number,\n        default: 0\n    }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], \n    // deprecated\n    labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] });\nexport default defineComponent({\n    name: 'Tabs',\n    props: tabsProps,\n    setup(props, { slots }) {\n        var _a, _b, _c, _d;\n        if (process.env.NODE_ENV !== 'production') {\n            watchEffect(() => {\n                if (props.labelSize !== undefined) {\n                    warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n                }\n                if (props.activeName !== undefined) {\n                    warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n                }\n                if (props.onActiveNameChange !== undefined) {\n                    warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n                }\n            });\n        }\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n        const tabsElRef = ref(null);\n        const barElRef = ref(null);\n        const scrollWrapperElRef = ref(null);\n        const addTabInstRef = ref(null);\n        const xScrollInstRef = ref(null);\n        const leftReachedRef = ref(true);\n        const rightReachedRef = ref(true);\n        const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n        const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n        const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : (slots.default\n            ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name\n            : null));\n        const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n        const tabChangeIdRef = { id: 0 };\n        const tabWrapperStyleRef = computed(() => {\n            if (!props.justifyContent || props.type === 'card')\n                return undefined;\n            return {\n                display: 'flex',\n                justifyContent: props.justifyContent\n            };\n        });\n        watch(mergedValueRef, () => {\n            tabChangeIdRef.id = 0;\n            updateCurrentBarStyle();\n            updateCurrentScrollPosition(true);\n        });\n        function getCurrentEl() {\n            var _a;\n            const { value } = mergedValueRef;\n            if (value === null)\n                return null;\n            const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n            return tabEl;\n        }\n        function updateBarStyle(tabEl) {\n            if (props.type === 'card')\n                return;\n            const { value: barEl } = barElRef;\n            if (!barEl)\n                return;\n            if (tabEl) {\n                const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n                const { barWidth } = props;\n                if (tabEl.dataset.disabled === 'true') {\n                    barEl.classList.add(disabledClassName);\n                }\n                else {\n                    barEl.classList.remove(disabledClassName);\n                }\n                if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n                    const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n                    barEl.style.left = `${offsetDiffLeft}px`;\n                    barEl.style.maxWidth = `${barWidth}px`;\n                }\n                else {\n                    barEl.style.left = `${tabEl.offsetLeft}px`;\n                    barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n                }\n                barEl.style.width = '8192px';\n                void barEl.offsetWidth;\n            }\n        }\n        function updateCurrentBarStyle() {\n            if (props.type === 'card')\n                return;\n            const tabEl = getCurrentEl();\n            if (tabEl) {\n                updateBarStyle(tabEl);\n            }\n        }\n        function updateCurrentScrollPosition(smooth) {\n            var _a;\n            const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n            if (!scrollWrapperEl)\n                return;\n            const tabEl = getCurrentEl();\n            if (!tabEl)\n                return;\n            const { scrollLeft: scrollWrapperElScrollLeft, offsetWidth: scrollWrapperElOffsetWidth } = scrollWrapperEl;\n            const { offsetLeft: tabElOffsetLeft, offsetWidth: tabElOffsetWidth } = tabEl;\n            if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n                scrollWrapperEl.scrollTo({\n                    top: 0,\n                    left: tabElOffsetLeft,\n                    behavior: 'smooth'\n                });\n            }\n            else if (tabElOffsetLeft + tabElOffsetWidth >\n                scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n                scrollWrapperEl.scrollTo({\n                    top: 0,\n                    left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n                    behavior: 'smooth'\n                });\n            }\n        }\n        const tabsPaneWrapperRef = ref(null);\n        let fromHeight = 0;\n        let hangingTransition = null;\n        function onAnimationBeforeLeave(el) {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                fromHeight = el.getBoundingClientRect().height;\n                const fromHeightPx = `${fromHeight}px`;\n                const applyFromStyle = () => {\n                    tabsPaneWrapperEl.style.height = fromHeightPx;\n                    tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n                };\n                if (!hangingTransition) {\n                    hangingTransition = applyFromStyle;\n                }\n                else {\n                    applyFromStyle();\n                    hangingTransition();\n                    hangingTransition = null;\n                }\n            }\n        }\n        function onAnimationEnter(el) {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                const targetHeight = el.getBoundingClientRect().height;\n                const applyTargetStyle = () => {\n                    void document.body.offsetHeight;\n                    tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n                    tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n                };\n                if (!hangingTransition) {\n                    hangingTransition = applyTargetStyle;\n                }\n                else {\n                    hangingTransition();\n                    hangingTransition = null;\n                    applyTargetStyle();\n                }\n            }\n        }\n        function onAnimationAfterEnter() {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                tabsPaneWrapperEl.style.maxHeight = '';\n                tabsPaneWrapperEl.style.height = '';\n            }\n        }\n        const renderNameListRef = { value: [] };\n        const animationDirectionRef = ref('next');\n        function activateTab(panelName) {\n            const currentValue = mergedValueRef.value;\n            let dir = 'next';\n            for (const name of renderNameListRef.value) {\n                if (name === currentValue) {\n                    break;\n                }\n                if (name === panelName) {\n                    dir = 'prev';\n                    break;\n                }\n            }\n            animationDirectionRef.value = dir;\n            doUpdateValue(panelName);\n        }\n        function doUpdateValue(panelName) {\n            const { onActiveNameChange, onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;\n            if (onActiveNameChange) {\n                call(onActiveNameChange, panelName);\n            }\n            if (onUpdateValue)\n                call(onUpdateValue, panelName);\n            if (_onUpdateValue)\n                call(_onUpdateValue, panelName);\n            uncontrolledValueRef.value = panelName;\n        }\n        function handleClose(panelName) {\n            const { onClose } = props;\n            if (onClose)\n                call(onClose, panelName);\n        }\n        let firstTimeUpdatePosition = true;\n        function updateBarPositionInstantly() {\n            const { value: barEl } = barElRef;\n            if (!barEl)\n                return;\n            if (!firstTimeUpdatePosition)\n                firstTimeUpdatePosition = false;\n            const disableTransitionClassName = 'transition-disabled';\n            barEl.classList.add(disableTransitionClassName);\n            updateCurrentBarStyle();\n            // here we don't need to force layout after update bar style\n            // since deriveScrollShadow will force layout\n            barEl.classList.remove(disableTransitionClassName);\n        }\n        let memorizedWidth = 0;\n        function _handleNavResize(entry) {\n            var _a, _b;\n            if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n                return;\n            }\n            if (memorizedWidth === entry.contentRect.width) {\n                return;\n            }\n            memorizedWidth = entry.contentRect.width;\n            const { type } = props;\n            if (type === 'line' || type === 'bar') {\n                if (firstTimeUpdatePosition ||\n                    ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n                    updateBarPositionInstantly();\n                }\n            }\n            if (type !== 'segment') {\n                deriveScrollShadow((_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el);\n            }\n        }\n        const handleNavResize = throttle(_handleNavResize, 64);\n        watch([() => props.justifyContent, () => props.size], () => {\n            void nextTick(() => {\n                const { type } = props;\n                if (type === 'line' || type === 'bar') {\n                    updateBarPositionInstantly();\n                }\n            });\n        });\n        const addTabFixedRef = ref(false);\n        function _handleTabsResize(entry) {\n            var _a;\n            const { target, contentRect: { width } } = entry;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const containerWidth = target.parentElement.offsetWidth;\n            if (!addTabFixedRef.value) {\n                if (containerWidth < width) {\n                    addTabFixedRef.value = true;\n                }\n            }\n            else {\n                const { value: addTabInst } = addTabInstRef;\n                if (!addTabInst)\n                    return;\n                if (containerWidth - width > addTabInst.$el.offsetWidth) {\n                    addTabFixedRef.value = false;\n                }\n            }\n            deriveScrollShadow((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el);\n        }\n        const handleTabsResize = throttle(_handleTabsResize, 64);\n        function handleAdd() {\n            const { onAdd } = props;\n            if (onAdd)\n                onAdd();\n            void nextTick(() => {\n                const currentEl = getCurrentEl();\n                const { value: xScrollInst } = xScrollInstRef;\n                if (!currentEl || !xScrollInst)\n                    return;\n                xScrollInst.scrollTo({\n                    left: currentEl.offsetLeft,\n                    top: 0,\n                    behavior: 'smooth'\n                });\n            });\n        }\n        function deriveScrollShadow(el) {\n            if (!el)\n                return;\n            const { scrollLeft, scrollWidth, offsetWidth } = el;\n            leftReachedRef.value = scrollLeft <= 0;\n            rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n        }\n        const handleScroll = throttle((e) => {\n            deriveScrollShadow(e.target);\n        }, 64);\n        provide(tabsInjectionKey, {\n            triggerRef: toRef(props, 'trigger'),\n            tabStyleRef: toRef(props, 'tabStyle'),\n            paneClassRef: toRef(props, 'paneClass'),\n            paneStyleRef: toRef(props, 'paneStyle'),\n            mergedClsPrefixRef,\n            typeRef: toRef(props, 'type'),\n            closableRef: toRef(props, 'closable'),\n            valueRef: mergedValueRef,\n            tabChangeIdRef,\n            onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n            activateTab,\n            handleClose,\n            handleAdd\n        });\n        onFontsReady(() => {\n            updateCurrentBarStyle();\n            updateCurrentScrollPosition(true);\n        });\n        // avoid useless rerender\n        watchEffect(() => {\n            const { value: el } = scrollWrapperElRef;\n            if (!el)\n                return;\n            const { value: clsPrefix } = mergedClsPrefixRef;\n            const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;\n            const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;\n            if (leftReachedRef.value) {\n                el.classList.remove(shadowBeforeClass);\n            }\n            else {\n                el.classList.add(shadowBeforeClass);\n            }\n            if (rightReachedRef.value) {\n                el.classList.remove(shadowAfterClass);\n            }\n            else {\n                el.classList.add(shadowAfterClass);\n            }\n        });\n        const tabsRailElRef = ref(null);\n        watch(mergedValueRef, () => {\n            if (props.type === 'segment') {\n                const tabsRailEl = tabsRailElRef.value;\n                if (tabsRailEl) {\n                    void nextTick(() => {\n                        tabsRailEl.classList.add('transition-disabled');\n                        void tabsRailEl.offsetWidth;\n                        tabsRailEl.classList.remove('transition-disabled');\n                    });\n                }\n            }\n        });\n        const exposedMethods = {\n            syncBarPosition: () => {\n                updateCurrentBarStyle();\n            }\n        };\n        const cssVarsRef = computed(() => {\n            const { value: size } = compitableSizeRef;\n            const { type } = props;\n            const typeSuffix = {\n                card: 'Card',\n                bar: 'Bar',\n                line: 'Line',\n                segment: 'Segment'\n            }[type];\n            const sizeType = `${size}${typeSuffix}`;\n            const { self: { barColor, closeIconColor, closeIconColorHover, closeIconColorPressed, tabColor, tabBorderColor, paneTextColor, tabFontWeight, tabBorderRadius, tabFontWeightActive, colorSegment, fontWeightStrong, tabColorSegment, closeSize, closeIconSize, closeColorHover, closeColorPressed, closeBorderRadius, [createKey('panePadding', size)]: panePadding, [createKey('tabPadding', sizeType)]: tabPadding, [createKey('tabGap', sizeType)]: tabGap, [createKey('tabTextColor', type)]: tabTextColor, [createKey('tabTextColorActive', type)]: tabTextColorActive, [createKey('tabTextColorHover', type)]: tabTextColorHover, [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled, [createKey('tabFontSize', size)]: tabFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-color-segment': colorSegment,\n                '--n-bar-color': barColor,\n                '--n-tab-font-size': tabFontSize,\n                '--n-tab-text-color': tabTextColor,\n                '--n-tab-text-color-active': tabTextColorActive,\n                '--n-tab-text-color-disabled': tabTextColorDisabled,\n                '--n-tab-text-color-hover': tabTextColorHover,\n                '--n-pane-text-color': paneTextColor,\n                '--n-tab-border-color': tabBorderColor,\n                '--n-tab-border-radius': tabBorderRadius,\n                '--n-close-size': closeSize,\n                '--n-close-icon-size': closeIconSize,\n                '--n-close-color-hover': closeColorHover,\n                '--n-close-color-pressed': closeColorPressed,\n                '--n-close-border-radius': closeBorderRadius,\n                '--n-close-icon-color': closeIconColor,\n                '--n-close-icon-color-hover': closeIconColorHover,\n                '--n-close-icon-color-pressed': closeIconColorPressed,\n                '--n-tab-color': tabColor,\n                '--n-tab-font-weight': tabFontWeight,\n                '--n-tab-font-weight-active': tabFontWeightActive,\n                '--n-tab-padding': tabPadding,\n                '--n-tab-gap': tabGap,\n                '--n-pane-padding': panePadding,\n                '--n-font-weight-strong': fontWeightStrong,\n                '--n-tab-color-segment': tabColorSegment\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tabs', computed(() => {\n                return `${compitableSizeRef.value[0]}${props.type[0]}`;\n            }), cssVarsRef, props)\n            : undefined;\n        return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedValue: mergedValueRef, renderedNames: new Set(), tabsRailElRef,\n            tabsPaneWrapperRef,\n            tabsElRef,\n            barElRef,\n            addTabInstRef,\n            xScrollInstRef,\n            scrollWrapperElRef, addTabFixed: addTabFixedRef, tabWrapperStyle: tabWrapperStyleRef, handleNavResize, mergedSize: compitableSizeRef, handleScroll,\n            handleTabsResize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, animationDirection: animationDirectionRef, renderNameListRef,\n            onAnimationBeforeLeave,\n            onAnimationEnter,\n            onAnimationAfterEnter, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);\n    },\n    render() {\n        const { mergedClsPrefix, type, addTabFixed, addable, mergedSize, renderNameListRef, onRender, $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;\n        onRender === null || onRender === void 0 ? void 0 : onRender();\n        const tabPaneChildren = defaultSlot\n            ? flatten(defaultSlot()).filter((v) => {\n                return v.type.__TAB_PANE__ === true;\n            })\n            : [];\n        const tabChildren = defaultSlot\n            ? flatten(defaultSlot()).filter((v) => {\n                return v.type.__TAB__ === true;\n            })\n            : [];\n        const showPane = !tabChildren.length;\n        const isCard = type === 'card';\n        const isSegment = type === 'segment';\n        const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n        renderNameListRef.value = [];\n        return (h(\"div\", { class: [\n                `${mergedClsPrefix}-tabs`,\n                this.themeClass,\n                `${mergedClsPrefix}-tabs--${type}-type`,\n                `${mergedClsPrefix}-tabs--${mergedSize}-size`,\n                mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`\n            ], style: this.cssVars },\n            h(\"div\", { class: [\n                    // the class should be applied here since it's possible\n                    // to make tabs nested in tabs, style may influence each\n                    // other. adding a class will make it easy to write the\n                    // style.\n                    `${mergedClsPrefix}-tabs-nav--${type}-type`,\n                    `${mergedClsPrefix}-tabs-nav`\n                ] },\n                resolveWrappedSlot(prefixSlot, (children) => children && (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav__prefix` }, children))),\n                isSegment ? (h(\"div\", { class: `${mergedClsPrefix}-tabs-rail`, ref: \"tabsRailElRef\" }, showPane\n                    ? tabPaneChildren.map((tabPaneVNode, index) => {\n                        renderNameListRef.value.push(tabPaneVNode.props.name);\n                        return (h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 }), tabPaneVNode.children\n                            ? {\n                                default: tabPaneVNode.children.tab\n                            }\n                            : undefined));\n                    })\n                    : tabChildren.map((tabVNode, index) => {\n                        renderNameListRef.value.push(tabVNode.props.name);\n                        if (index === 0) {\n                            return tabVNode;\n                        }\n                        else {\n                            return createLeftPaddedTabVNode(tabVNode);\n                        }\n                    }))) : (h(VResizeObserver, { onResize: this.handleNavResize }, {\n                    default: () => (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`, ref: \"scrollWrapperElRef\" },\n                        h(VXScroll, { ref: \"xScrollInstRef\", onScroll: this.handleScroll }, {\n                            default: () => {\n                                const rawWrappedTabs = (h(\"div\", { style: this.tabWrapperStyle, class: `${mergedClsPrefix}-tabs-wrapper` },\n                                    mergedJustifyContent ? null : (h(\"div\", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } })),\n                                    showPane\n                                        ? tabPaneChildren.map((tabPaneVNode, index) => {\n                                            renderNameListRef.value.push(tabPaneVNode.props.name);\n                                            return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 &&\n                                                    (!mergedJustifyContent ||\n                                                        mergedJustifyContent ===\n                                                            'center' ||\n                                                        mergedJustifyContent ===\n                                                            'start' ||\n                                                        mergedJustifyContent === 'end') }), tabPaneVNode.children\n                                                ? {\n                                                    default: tabPaneVNode.children.tab\n                                                }\n                                                : undefined));\n                                        })\n                                        : tabChildren.map((tabVNode, index) => {\n                                            renderNameListRef.value.push(tabVNode.props.name);\n                                            if (index !== 0 &&\n                                                !mergedJustifyContent) {\n                                                return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n                                            }\n                                            else {\n                                                return justifyTabDynamicProps(tabVNode);\n                                            }\n                                        }),\n                                    !addTabFixed && addable && isCard\n                                        ? createAddTag(addable, (showPane\n                                            ? tabPaneChildren.length\n                                            : tabChildren.length) !== 0)\n                                        : null,\n                                    mergedJustifyContent ? null : (h(\"div\", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }))));\n                                let wrappedTabs = rawWrappedTabs;\n                                if (isCard && addable) {\n                                    wrappedTabs = (h(VResizeObserver, { onResize: this.handleTabsResize }, {\n                                        default: () => rawWrappedTabs\n                                    }));\n                                }\n                                return (h(\"div\", { ref: \"tabsElRef\", class: `${mergedClsPrefix}-tabs-nav-scroll-content` },\n                                    wrappedTabs,\n                                    isCard ? (h(\"div\", { class: `${mergedClsPrefix}-tabs-pad` })) : null,\n                                    isCard ? null : (h(\"div\", { ref: \"barElRef\", class: `${mergedClsPrefix}-tabs-bar` }))));\n                            }\n                        })))\n                })),\n                addTabFixed && addable && isCard\n                    ? createAddTag(addable, true)\n                    : null,\n                resolveWrappedSlot(suffixSlot, (children) => children && (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav__suffix` }, children)))),\n            showPane &&\n                (this.animated ? (h(\"div\", { ref: \"tabsPaneWrapperRef\", class: `${mergedClsPrefix}-tabs-pane-wrapper` }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection))) : (filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)))));\n    }\n});\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n    const children = [];\n    tabPaneVNodes.forEach((vNode) => {\n        const { name, displayDirective, 'display-directive': _displayDirective } = vNode.props;\n        const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;\n        const show = value === name;\n        if (vNode.key !== undefined) {\n            vNode.key = name;\n        }\n        if (show ||\n            matchDisplayDirective('show') ||\n            (matchDisplayDirective('show:lazy') && renderedNames.has(name))) {\n            if (!renderedNames.has(name)) {\n                renderedNames.add(name);\n            }\n            const useVShow = !matchDisplayDirective('if');\n            children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n        }\n    });\n    if (!animationDirection) {\n        return children;\n    }\n    return (h(TransitionGroup, { name: `${animationDirection}-transition`, onBeforeLeave: onBeforeLeave, onEnter: onEnter, onAfterEnter: onAfterEnter }, { default: () => children }));\n}\nfunction createAddTag(addable, internalLeftPadded) {\n    return (h(Tab, { ref: \"addTabInstRef\", key: \"__addable\", name: \"__addable\", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: internalLeftPadded, disabled: typeof addable === 'object' && addable.disabled }));\n}\nfunction createLeftPaddedTabVNode(tabVNode) {\n    const modifiedVNode = cloneVNode(tabVNode);\n    if (modifiedVNode.props) {\n        modifiedVNode.props.internalLeftPadded = true;\n    }\n    else {\n        modifiedVNode.props = {\n            internalLeftPadded: true\n        };\n    }\n    return modifiedVNode;\n}\nfunction justifyTabDynamicProps(tabVNode) {\n    if (Array.isArray(tabVNode.dynamicProps)) {\n        if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n            tabVNode.dynamicProps.push('internalLeftPadded');\n        }\n    }\n    else {\n        tabVNode.dynamicProps = ['internalLeftPadded'];\n    }\n    return tabVNode;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}