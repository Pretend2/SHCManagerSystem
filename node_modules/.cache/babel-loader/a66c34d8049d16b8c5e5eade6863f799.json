{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nimport { NEmpty } from '../../empty'; // TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\n\nconst ITEM_SIZE = 30; // 24 + 3 + 3\n\nexport function createTreeMateOptions(keyField, childrenField, disabledField) {\n  return {\n    getIsGroup() {\n      return false;\n    },\n\n    getKey(node) {\n      return node[keyField];\n    },\n\n    getChildren(node) {\n      return node[childrenField];\n    },\n\n    getDisabled(node) {\n      return !!(node[disabledField] || node.checkboxDisabled);\n    }\n\n  };\n}\nexport const treeSharedProps = {\n  allowCheckingNotLoaded: Boolean,\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  disabledField: {\n    type: String,\n    default: 'disabled'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  renderSwitcherIcon: Function,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  accordion: Boolean,\n  showIrrelevantNodes: {\n    type: Boolean,\n    default: true\n  },\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  expandOnClick: Boolean,\n  checkOnClick: {\n    type: [Boolean, Function],\n    default: false\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  indent: {\n    type: Number,\n    default: 16\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  checkboxPlacement: {\n    type: String,\n    default: 'left'\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  nodeProps: Function,\n  keyboard: {\n    type: Boolean,\n    default: true\n  },\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to display\n  internalRenderEmpty: Function,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  },\n\n  /**\n   * @deprecated\n   */\n  leafOnly: Boolean\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.leafOnly) {\n          warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n        }\n      });\n    }\n\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled,\n      mergedRtlRef\n    } = useConfig(props);\n    const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n\n    function getScrollContainer() {\n      var _a;\n\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n\n    function getScrollContent() {\n      var _a;\n\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    }\n\n    const filteredTreeInfoRef = computed(() => {\n      const {\n        pattern\n      } = props;\n\n      if (!pattern) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n\n      if (!pattern.length || !mergedFilterRef.value) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n\n      return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n    }); // We don't expect data source to change so we just determine it once\n\n    const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField)));\n    const treeSelectInjection = inject(treeSelectInjectionKey, null);\n    const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => initUncontrolledExpandedKeys(undefined));\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n    }\n\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeydown\n    } = useKeyboard({\n      props,\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = computed(() => {\n      return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;\n    });\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null; // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n\n      return droppingNode.parent;\n    });\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        const label = node[labelField];\n\n        if (typeof label === 'string') {\n          return label.toLowerCase().includes(pattern.toLowerCase());\n        }\n\n        return false;\n      };\n    }); // shallow watch data\n\n    watch(toRef(props, 'data'), () => {\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    let expandAnimationDisabled = false;\n\n    const disableExpandAnimationForOneTick = () => {\n      expandAnimationDisabled = true;\n      void nextTick(() => {\n        expandAnimationDisabled = false;\n      });\n    };\n\n    let memoizedExpandedKeys;\n    watch(toRef(props, 'pattern'), (value, oldValue) => {\n      if (props.showIrrelevantNodes) {\n        memoizedExpandedKeys = undefined;\n\n        if (value) {\n          const {\n            expandedKeys: expandedKeysAfterChange,\n            highlightKeySet\n          } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n          uncontrolledHighlightKeySetRef.value = highlightKeySet;\n          disableExpandAnimationForOneTick();\n          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n        } else {\n          uncontrolledHighlightKeySetRef.value = new Set();\n        }\n      } else {\n        if (!value.length) {\n          if (memoizedExpandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys));\n          }\n        } else {\n          if (!oldValue.length) {\n            memoizedExpandedKeys = mergedExpandedKeysRef.value;\n          }\n\n          const {\n            expandedKeys\n          } = filteredTreeInfoRef.value;\n\n          if (expandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys));\n          }\n        }\n      }\n    });\n\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n\n          return yield Promise.resolve();\n        }\n\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        return yield new Promise(resolve => {\n          if (!loadingKeys.has(node.key)) {\n            loadingKeys.add(node.key);\n            onLoad(node.rawNode).then(() => {\n              loadingKeys.delete(node.key);\n              resolve();\n            }).catch(loadError => {\n              console.error(loadError);\n              resetDragExpandState();\n            });\n          }\n        });\n      });\n    }\n\n    watchEffect(() => {\n      var _a;\n\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    }); // animation in progress\n\n    const aipRef = ref(false); // animation flattened nodes\n\n    const afNodesRef = ref([]); // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated || expandAnimationDisabled) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n\n          addedKey = expandedKey;\n        }\n      }\n\n      const currentVSet = new Set(value);\n\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n\n          removedKey = expandedKey;\n        }\n      }\n\n      if (addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1; // play add animation\n\n      let baseExpandedKeys;\n\n      if (addedKey !== null) {\n        baseExpandedKeys = prevValue;\n      }\n\n      if (removedKey !== null) {\n        if (baseExpandedKeys === undefined) {\n          baseExpandedKeys = value;\n        } else {\n          baseExpandedKeys = baseExpandedKeys.filter(key => key !== removedKey);\n        }\n      }\n\n      aipRef.value = true;\n      afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n\n      if (addedKey !== null) {\n        const expandedNodeIndex = afNodesRef.value.findIndex(node => node.key === addedKey);\n\n        if (~expandedNodeIndex) {\n          const children = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodesRef.value[expandedNodeIndex].children; // sometimes user will pass leaf keys in\n\n          if (children) {\n            const expandedChildren = flatten(children, value);\n            afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n              __motion: true,\n              mode: 'expand',\n              height: virtualScroll ? expandedChildren.length * ITEM_SIZE : undefined,\n              nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n            });\n          }\n        }\n      }\n\n      if (removedKey !== null) {\n        const collapsedNodeIndex = afNodesRef.value.findIndex(node => node.key === removedKey);\n\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children; // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n\n          if (!collapsedNodeChildren) return; // play remove animation\n\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * ITEM_SIZE : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodesRef.value;else return fNodesRef.value;\n    });\n\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n\n    function handleAfterEnter() {\n      aipRef.value = false;\n\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n\n    function doUpdateExpandedKeys(value, option) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option);\n      }\n\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option);\n      }\n    }\n\n    function doUpdateCheckedKeys(value, option) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option);\n      }\n\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option);\n      }\n    }\n\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n\n    function doUpdateSelectedKeys(value, option) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option);\n      }\n\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option);\n      }\n    } // Drag & Drop\n\n\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n\n      nodeKeyToBeExpanded = null;\n    }\n\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n\n    function toggleExpand(node) {\n      if (props.disabled) return;\n      const {\n        key\n      } = node;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n\n        let nextKeys;\n\n        if (props.accordion) {\n          const siblingKeySet = new Set(node.siblings.map(({\n            key\n          }) => key));\n          nextKeys = mergedExpandedKeys.filter(expandedKey => {\n            return !siblingKeySet.has(expandedKey);\n          });\n          nextKeys.push(key);\n        } else {\n          nextKeys = mergedExpandedKeys.concat(key);\n        }\n\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n      }\n    }\n\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node);\n    }\n\n    function handleSelect(node) {\n      if (props.disabled || !props.selectable) {\n        return;\n      }\n\n      pendingNodeKeyRef.value = node.key;\n\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], []);\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n    }\n\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      } // Don't expand leaf node.\n\n\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n        }\n\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    } // Dnd\n\n\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    } // Dragend is ok, we don't need to add global listener to reset drag status\n\n\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      } // Most of time, the image will block user's view\n\n\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      }); // Update dropping node\n\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n\n      /** the dropping node needn't to be the mouse hovering node! */\n\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n\n      let mouseAtExpandedNonLeafNode = false;\n\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      } // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n\n\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode; // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n\n        let offsetLevel = 0;\n\n        while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      } // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n\n\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {// This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      } // Bailout 3\n\n\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode); // Bailout 4\n              // not try to loading\n\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      } // Bailout 1\n\n\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      } // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n\n\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      } // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n\n\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n\n    function handleScroll() {\n      syncScrollbar();\n    }\n\n    function handleResize() {\n      syncScrollbar();\n    }\n\n    function handleFocusout(e) {\n      var _a;\n\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n\n      if (value === null) return;\n\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      expandOnClickRef: toRef(props, 'expandOnClick'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      checkOnClickRef: toRef(props, 'checkOnClick'),\n      checkboxPlacementRef: props.checkboxPlacement,\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      disabledFieldRef: toRef(props, 'disabledField'),\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n\n    function scrollTo(options) {\n      var _a;\n\n      (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n    }\n\n    const exposedMethods = {\n      handleKeydown,\n      scrollTo\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      rtlEnabled: rtlEnabledRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      handleKeydown: exposedMethods.handleKeydown,\n      scrollTo: exposedMethods.scrollTo,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    };\n  },\n\n  render() {\n    var _a;\n\n    const {\n      fNodes,\n      internalRenderEmpty\n    } = this;\n\n    if (!fNodes.length && internalRenderEmpty) {\n      return internalRenderEmpty();\n    }\n\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeydown,\n      rtlEnabled,\n      handleFocusout\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }, {\n        default: () => {\n          var _a;\n\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: ITEM_SIZE,\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (internalScrollable) {\n      return h(NxScrollbar, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }, {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n        class: `${mergedClsPrefix}-tree__empty`,\n        theme: this.mergedTheme.peers.Empty,\n        themeOverrides: this.mergedTheme.peerOverrides.Empty\n      })]) : fNodes.map(createNode));\n    }\n  }\n\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","h","ref","toRef","computed","defineComponent","provide","watch","nextTick","watchEffect","inject","createTreeMate","flatten","createIndexGetter","useMergedState","VVirtualList","getPadding","treeSelectInjectionKey","useConfig","useTheme","useThemeClass","useRtl","call","createDataKey","resolveSlot","warn","warnOnce","NxScrollbar","treeLight","NTreeNode","keysWithFilter","emptyImage","filterTree","isNodeDisabled","useKeyboard","treeInjectionKey","MotionWrapper","defaultAllowDrop","style","NEmpty","ITEM_SIZE","createTreeMateOptions","keyField","childrenField","disabledField","getIsGroup","getKey","node","getChildren","getDisabled","checkboxDisabled","treeSharedProps","allowCheckingNotLoaded","Boolean","filter","Function","defaultExpandAll","expandedKeys","Array","type","String","default","labelField","defaultExpandedKeys","indeterminateKeys","renderSwitcherIcon","onUpdateIndeterminateKeys","onUpdateExpandedKeys","treeProps","Object","assign","props","accordion","showIrrelevantNodes","data","expandOnDragenter","expandOnClick","checkOnClick","cancelable","checkable","draggable","blockNode","blockLine","disabled","checkedKeys","defaultCheckedKeys","selectedKeys","defaultSelectedKeys","multiple","pattern","onLoad","cascade","selectable","indent","Number","allowDrop","animated","checkboxPlacement","virtualScroll","watchProps","renderLabel","renderPrefix","renderSuffix","nodeProps","keyboard","onDragenter","onDragleave","onDragend","onDragstart","onDragover","onDrop","onUpdateCheckedKeys","onUpdateSelectedKeys","internalTreeSelect","internalScrollable","internalScrollablePadding","internalRenderEmpty","internalHighlightKeySet","internalUnifySelectCheck","internalCheckboxFocusable","internalFocusable","checkStrategy","leafOnly","name","setup","process","env","NODE_ENV","mergedClsPrefixRef","inlineThemeDisabled","mergedRtlRef","rtlEnabledRef","themeRef","selfElRef","scrollbarInstRef","virtualListInstRef","getScrollContainer","_a","listElRef","getScrollContent","itemsElRef","filteredTreeInfoRef","filteredTree","highlightKeySet","undefined","length","mergedFilterRef","displayTreeMateRef","treeSelectInjection","dataTreeMateRef","dataTreeMate","uncontrolledCheckedKeysRef","includes","controlledCheckedKeysRef","mergedCheckedKeysRef","checkedStatusRef","getCheckedKeys","allowNotLoaded","mergedCheckStrategyRef","displayedCheckedKeysRef","displayedIndeterminateKeysRef","uncontrolledSelectedKeysRef","controlledSelectedKeysRef","mergedSelectedKeysRef","uncontrolledExpandedKeysRef","initUncontrolledExpandedKeys","keys","getNonLeafKeys","controlledExpandedKeysRef","mergedExpandedKeysRef","fNodesRef","getFlattenedNodes","pendingNodeKeyRef","handleKeydown","handleSelect","handleSwitcherClick","expandTimerId","nodeKeyToBeExpanded","uncontrolledHighlightKeySetRef","Set","controlledHighlightKeySetRef","mergedHighlightKeySetRef","loadingKeysRef","expandedNonLoadingKeysRef","key","has","dragStartX","draggingNodeRef","droppingNodeRef","droppingMouseNodeRef","droppingPositionRef","droppingOffsetLevelRef","droppingNodeParentRef","droppingNode","parent","label","toLowerCase","clear","resetDndState","deep","expandAnimationDisabled","disableExpandAnimationForOneTick","memoizedExpandedKeys","oldValue","expandedKeysAfterChange","doUpdateExpandedKeys","getOptionsByKeys","triggerLoading","loadingKeys","add","rawNode","delete","catch","loadError","console","error","resetDragExpandState","displayTreeMate","getNode","forEach","shallowLoaded","aipRef","afNodesRef","prevValue","syncScrollbar","prevVSet","addedKey","removedKey","expandedKey","currentVSet","viewportHeight","offsetHeight","viewportItemCount","Math","ceil","baseExpandedKeys","expandedNodeIndex","findIndex","children","expandedChildren","splice","__motion","mode","height","nodes","slice","collapsedNodeIndex","collapsedNodeChildren","collapsedChildren","getFIndexRef","mergedFNodesRef","scrollbarInst","sync","handleAfterEnter","map","option","_onUpdateExpandedKeys","doUpdateCheckedKeys","_onUpdateCheckedKeys","doUpdateIndeterminateKeys","_onUpdateIndeterminateKeys","doUpdateSelectedKeys","_onUpdateSelectedKeys","doDragEnter","info","doDragLeave","doDragEnd","doDragStart","doDragOver","doDrop","resetDragState","resetDropState","window","clearTimeout","handleCheck","checked","toggleExpand","mergedExpandedKeys","index","expandNodeId","from","nodeToBeExpanded","isLeaf","nextKeys","siblingKeySet","siblings","push","concat","expandDragEnterNode","expand","droppingMouseNode","setTimeout","handleDragEnter","event","handleDragOver","handleDragLeave","handleDragLeaveTree","target","currentTarget","handleDragEnd","handleDragStart","dataTransfer","setDragImage","clientX","emit","draggingNode","el","elOffsetHeight","top","elClientTop","getBoundingClientRect","eventOffsetY","clientY","mousePosition","allowDropInside","dropPosition","phase","getFindex","finalDropNode","finalDropPosition","hoverNodeFIndex","mouseAtExpandedNonLeafNode","isFirstChild","isLastChild","offset","offsetLevel","contains","handleDrop","droppingPosition","nextNode","getNext","includeDisabled","prevNode","getPrev","dragNode","handleScroll","handleResize","handleFocusout","containerRef","relatedTarget","selfEl","_b","scrollTo","targetEl","contentRef","querySelector","highlightKeySetRef","mergedThemeRef","nodePropsRef","disabledRef","checkableRef","selectableRef","expandOnClickRef","onLoadRef","draggableRef","blockLineRef","indentRef","cascadeRef","checkOnClickRef","checkboxPlacementRef","disabledFieldRef","internalScrollableRef","internalCheckboxFocusableRef","renderLabelRef","renderPrefixRef","renderSuffixRef","renderSwitcherIconRef","labelFieldRef","multipleRef","options","exposedMethods","cssVarsRef","common","cubicBezierEaseInOut","self","fontSize","nodeBorderRadius","nodeColorHover","nodeColorPressed","nodeColorActive","arrowColor","loadingColor","nodeTextColor","nodeTextColorDisabled","dropMarkColor","themeClassHandle","mergedClsPrefix","mergedTheme","rtlEnabled","fNodes","aip","cssVars","themeClass","onRender","render","mergedFocusable","tabindex","treeClass","createNode","tmNode","clsPrefix","onAfterEnter","padding","container","content","class","theme","peers","Scrollbar","themeOverrides","peerOverrides","onKeydown","onFocusout","items","itemSize","ignoreItemResize","paddingTop","paddingBottom","bottom","paddingLeft","left","paddingRight","right","onScroll","onResize","showScrollbar","itemResizable","item","contentStyle","$slots","empty","Empty"],"sources":["E:/VCode/SHC/shc_community_manager_system/node_modules/naive-ui/es/tree/src/Tree.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nimport { NEmpty } from '../../empty';\n// TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\nconst ITEM_SIZE = 30; // 24 + 3 + 3\nexport function createTreeMateOptions(keyField, childrenField, disabledField) {\n    return {\n        getIsGroup() {\n            return false;\n        },\n        getKey(node) {\n            return node[keyField];\n        },\n        getChildren(node) {\n            return node[childrenField];\n        },\n        getDisabled(node) {\n            return !!(node[disabledField] || node.checkboxDisabled);\n        }\n    };\n}\nexport const treeSharedProps = {\n    allowCheckingNotLoaded: Boolean,\n    filter: Function,\n    defaultExpandAll: Boolean,\n    expandedKeys: Array,\n    keyField: {\n        type: String,\n        default: 'key'\n    },\n    labelField: {\n        type: String,\n        default: 'label'\n    },\n    childrenField: {\n        type: String,\n        default: 'children'\n    },\n    disabledField: {\n        type: String,\n        default: 'disabled'\n    },\n    defaultExpandedKeys: {\n        type: Array,\n        default: () => []\n    },\n    indeterminateKeys: Array,\n    renderSwitcherIcon: Function,\n    onUpdateIndeterminateKeys: [Function, Array],\n    'onUpdate:indeterminateKeys': [Function, Array],\n    onUpdateExpandedKeys: [Function, Array],\n    'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { accordion: Boolean, showIrrelevantNodes: { type: Boolean, default: true }, data: {\n        type: Array,\n        default: () => []\n    }, expandOnDragenter: {\n        type: Boolean,\n        default: true\n    }, expandOnClick: Boolean, checkOnClick: {\n        type: [Boolean, Function],\n        default: false\n    }, cancelable: {\n        type: Boolean,\n        default: true\n    }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {\n        type: Array,\n        default: () => []\n    }, selectedKeys: Array, defaultSelectedKeys: {\n        type: Array,\n        default: () => []\n    }, multiple: Boolean, pattern: {\n        type: String,\n        default: ''\n    }, onLoad: Function, cascade: Boolean, selectable: {\n        type: Boolean,\n        default: true\n    }, indent: {\n        type: Number,\n        default: 16\n    }, allowDrop: {\n        type: Function,\n        default: defaultAllowDrop\n    }, animated: {\n        type: Boolean,\n        default: true\n    }, checkboxPlacement: {\n        type: String,\n        default: 'left'\n    }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, keyboard: {\n        type: Boolean,\n        default: true\n    }, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], 'onUpdate:checkedKeys': [Function, Array], onUpdateSelectedKeys: [Function, Array], 'onUpdate:selectedKeys': [Function, Array] }), treeSharedProps), { \n    // internal props for tree-select\n    internalTreeSelect: Boolean, internalScrollable: Boolean, internalScrollablePadding: String, \n    // use it to display\n    internalRenderEmpty: Function, internalHighlightKeySet: Object, internalUnifySelectCheck: Boolean, internalCheckboxFocusable: {\n        type: Boolean,\n        default: true\n    }, internalFocusable: {\n        // Make tree-select take over keyboard operations\n        type: Boolean,\n        default: true\n    }, checkStrategy: {\n        type: String,\n        default: 'all'\n    }, \n    /**\n     * @deprecated\n     */\n    leafOnly: Boolean });\nexport default defineComponent({\n    name: 'Tree',\n    props: treeProps,\n    setup(props) {\n        if (process.env.NODE_ENV !== 'production') {\n            watchEffect(() => {\n                if (props.leafOnly) {\n                    warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n                }\n            });\n        }\n        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);\n        const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n        const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n        const selfElRef = ref(null);\n        const scrollbarInstRef = ref(null);\n        const virtualListInstRef = ref(null);\n        function getScrollContainer() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n        }\n        function getScrollContent() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n        }\n        const filteredTreeInfoRef = computed(() => {\n            const { pattern } = props;\n            if (!pattern) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            if (!pattern.length || !mergedFilterRef.value) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n        });\n        // We don't expect data source to change so we just determine it once\n        const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes\n            ? props.data\n            : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField)));\n        const treeSelectInjection = inject(treeSelectInjectionKey, null);\n        const dataTreeMateRef = props.internalTreeSelect\n            ? treeSelectInjection.dataTreeMate\n            : displayTreeMateRef;\n        const { watchProps } = props;\n        const uncontrolledCheckedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n            watchEffect(() => {\n                uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n            });\n        }\n        else {\n            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n        }\n        const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n        const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n        const checkedStatusRef = computed(() => {\n            const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            return value;\n        });\n        const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n        const displayedCheckedKeysRef = computed(() => {\n            return checkedStatusRef.value.checkedKeys;\n        });\n        const displayedIndeterminateKeysRef = computed(() => {\n            const { indeterminateKeys } = props;\n            if (indeterminateKeys !== undefined)\n                return indeterminateKeys;\n            return checkedStatusRef.value.indeterminateKeys;\n        });\n        const uncontrolledSelectedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n            watchEffect(() => {\n                uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n            });\n        }\n        else {\n            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n        }\n        const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n        const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n        const uncontrolledExpandedKeysRef = ref([]);\n        const initUncontrolledExpandedKeys = (keys) => {\n            uncontrolledExpandedKeysRef.value = props.defaultExpandAll\n                ? dataTreeMateRef.value.getNonLeafKeys()\n                : keys === undefined\n                    ? props.defaultExpandedKeys\n                    : keys;\n        };\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n            // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n            watchEffect(() => initUncontrolledExpandedKeys(undefined));\n        }\n        else {\n            // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n            watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n        }\n        const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n        const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n        const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n        const { pendingNodeKeyRef, handleKeydown } = useKeyboard({\n            props,\n            mergedSelectedKeysRef,\n            fNodesRef,\n            mergedExpandedKeysRef,\n            handleSelect,\n            handleSwitcherClick\n        });\n        let expandTimerId = null;\n        let nodeKeyToBeExpanded = null;\n        const uncontrolledHighlightKeySetRef = ref(new Set());\n        const controlledHighlightKeySetRef = computed(() => {\n            return (props.internalHighlightKeySet ||\n                filteredTreeInfoRef.value.highlightKeySet);\n        });\n        const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n        const loadingKeysRef = ref(new Set());\n        const expandedNonLoadingKeysRef = computed(() => {\n            return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));\n        });\n        let dragStartX = 0;\n        const draggingNodeRef = ref(null);\n        const droppingNodeRef = ref(null);\n        const droppingMouseNodeRef = ref(null);\n        const droppingPositionRef = ref(null);\n        const droppingOffsetLevelRef = ref(0);\n        const droppingNodeParentRef = computed(() => {\n            const { value: droppingNode } = droppingNodeRef;\n            if (!droppingNode)\n                return null;\n            // May avoid overlap between line mark of first child & rect mark of parent\n            // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n            //   return null\n            // }\n            return droppingNode.parent;\n        });\n        const mergedFilterRef = computed(() => {\n            const { filter } = props;\n            if (filter)\n                return filter;\n            const { labelField } = props;\n            return (pattern, node) => {\n                if (!pattern.length)\n                    return true;\n                const label = node[labelField];\n                if (typeof label === 'string') {\n                    return label.toLowerCase().includes(pattern.toLowerCase());\n                }\n                return false;\n            };\n        });\n        // shallow watch data\n        watch(toRef(props, 'data'), () => {\n            loadingKeysRef.value.clear();\n            pendingNodeKeyRef.value = null;\n            resetDndState();\n        }, {\n            deep: false\n        });\n        let expandAnimationDisabled = false;\n        const disableExpandAnimationForOneTick = () => {\n            expandAnimationDisabled = true;\n            void nextTick(() => {\n                expandAnimationDisabled = false;\n            });\n        };\n        let memoizedExpandedKeys;\n        watch(toRef(props, 'pattern'), (value, oldValue) => {\n            if (props.showIrrelevantNodes) {\n                memoizedExpandedKeys = undefined;\n                if (value) {\n                    const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n                    uncontrolledHighlightKeySetRef.value = highlightKeySet;\n                    disableExpandAnimationForOneTick();\n                    doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n                }\n                else {\n                    uncontrolledHighlightKeySetRef.value = new Set();\n                }\n            }\n            else {\n                if (!value.length) {\n                    if (memoizedExpandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys));\n                    }\n                }\n                else {\n                    if (!oldValue.length) {\n                        memoizedExpandedKeys = mergedExpandedKeysRef.value;\n                    }\n                    const { expandedKeys } = filteredTreeInfoRef.value;\n                    if (expandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys));\n                    }\n                }\n            }\n        });\n        function triggerLoading(node) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { onLoad } = props;\n                if (!onLoad) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n                    }\n                    return yield Promise.resolve();\n                }\n                const { value: loadingKeys } = loadingKeysRef;\n                return yield new Promise((resolve) => {\n                    if (!loadingKeys.has(node.key)) {\n                        loadingKeys.add(node.key);\n                        onLoad(node.rawNode)\n                            .then(() => {\n                            loadingKeys.delete(node.key);\n                            resolve();\n                        })\n                            .catch((loadError) => {\n                            console.error(loadError);\n                            resetDragExpandState();\n                        });\n                    }\n                });\n            });\n        }\n        watchEffect(() => {\n            var _a;\n            const { value: displayTreeMate } = displayTreeMateRef;\n            if (!displayTreeMate)\n                return;\n            const { getNode } = displayTreeMate;\n            (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const node = getNode(key);\n                if (node && !node.shallowLoaded) {\n                    void triggerLoading(node);\n                }\n            });\n        });\n        // animation in progress\n        const aipRef = ref(false);\n        // animation flattened nodes\n        const afNodesRef = ref([]);\n        // Note: Since the virtual list depends on min height, if there's a node\n        // whose height starts from 0, the virtual list will have a wrong height\n        // during animation. This will seldom cause wired scrollbar status. It is\n        // fixable and need some changes in vueuc, I've no time so I just leave it\n        // here. Maybe the bug won't be fixed during the life time of the project.\n        watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n            if (!props.animated || expandAnimationDisabled) {\n                void nextTick(syncScrollbar);\n                return;\n            }\n            const prevVSet = new Set(prevValue);\n            let addedKey = null;\n            let removedKey = null;\n            for (const expandedKey of value) {\n                if (!prevVSet.has(expandedKey)) {\n                    if (addedKey !== null)\n                        return; // multi expand, not triggered by click\n                    addedKey = expandedKey;\n                }\n            }\n            const currentVSet = new Set(value);\n            for (const expandedKey of prevValue) {\n                if (!currentVSet.has(expandedKey)) {\n                    if (removedKey !== null)\n                        return; // multi collapse, not triggered by click\n                    removedKey = expandedKey;\n                }\n            }\n            if (addedKey === null && removedKey === null) {\n                // 1. multi action, not triggered by click\n                // 2. no action, don't know what happened\n                return;\n            }\n            const { virtualScroll } = props;\n            const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n            const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;\n            // play add animation\n            let baseExpandedKeys;\n            if (addedKey !== null) {\n                baseExpandedKeys = prevValue;\n            }\n            if (removedKey !== null) {\n                if (baseExpandedKeys === undefined) {\n                    baseExpandedKeys = value;\n                }\n                else {\n                    baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);\n                }\n            }\n            aipRef.value = true;\n            afNodesRef.value =\n                displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n            if (addedKey !== null) {\n                const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);\n                if (~expandedNodeIndex) {\n                    const children = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                     afNodesRef.value[expandedNodeIndex].children;\n                    // sometimes user will pass leaf keys in\n                    if (children) {\n                        const expandedChildren = flatten(children, value);\n                        afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n                            __motion: true,\n                            mode: 'expand',\n                            height: virtualScroll\n                                ? expandedChildren.length * ITEM_SIZE\n                                : undefined,\n                            nodes: virtualScroll\n                                ? expandedChildren.slice(0, viewportItemCount)\n                                : expandedChildren\n                        });\n                    }\n                }\n            }\n            if (removedKey !== null) {\n                const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);\n                if (~collapsedNodeIndex) {\n                    const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n                    // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n                    // but maybe children removed\n                    if (!collapsedNodeChildren)\n                        return;\n                    // play remove animation\n                    aipRef.value = true;\n                    const collapsedChildren = flatten(collapsedNodeChildren, value);\n                    afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n                        __motion: true,\n                        mode: 'collapse',\n                        height: virtualScroll\n                            ? collapsedChildren.length * ITEM_SIZE\n                            : undefined,\n                        nodes: virtualScroll\n                            ? collapsedChildren.slice(0, viewportItemCount)\n                            : collapsedChildren\n                    });\n                }\n            }\n        });\n        const getFIndexRef = computed(() => {\n            return createIndexGetter(fNodesRef.value);\n        });\n        const mergedFNodesRef = computed(() => {\n            if (aipRef.value)\n                return afNodesRef.value;\n            else\n                return fNodesRef.value;\n        });\n        function syncScrollbar() {\n            const { value: scrollbarInst } = scrollbarInstRef;\n            if (scrollbarInst)\n                scrollbarInst.sync();\n        }\n        function handleAfterEnter() {\n            aipRef.value = false;\n            if (props.virtualScroll) {\n                // If virtual scroll, we won't listen to resize during animation, so\n                // resize callback of virtual list won't be called and as a result\n                // scrollbar won't sync. We need to sync scrollbar manually.\n                void nextTick(syncScrollbar);\n            }\n        }\n        function getOptionsByKeys(keys) {\n            const { getNode } = dataTreeMateRef.value;\n            return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });\n        }\n        function doUpdateExpandedKeys(value, option) {\n            const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;\n            uncontrolledExpandedKeysRef.value = value;\n            if (_onUpdateExpandedKeys) {\n                call(_onUpdateExpandedKeys, value, option);\n            }\n            if (onUpdateExpandedKeys) {\n                call(onUpdateExpandedKeys, value, option);\n            }\n        }\n        function doUpdateCheckedKeys(value, option) {\n            const { 'onUpdate:checkedKeys': _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;\n            uncontrolledCheckedKeysRef.value = value;\n            if (onUpdateCheckedKeys) {\n                call(onUpdateCheckedKeys, value, option);\n            }\n            if (_onUpdateCheckedKeys) {\n                call(_onUpdateCheckedKeys, value, option);\n            }\n        }\n        function doUpdateIndeterminateKeys(value, option) {\n            const { 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;\n            if (_onUpdateIndeterminateKeys) {\n                call(_onUpdateIndeterminateKeys, value, option);\n            }\n            if (onUpdateIndeterminateKeys) {\n                call(onUpdateIndeterminateKeys, value, option);\n            }\n        }\n        function doUpdateSelectedKeys(value, option) {\n            const { 'onUpdate:selectedKeys': _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;\n            uncontrolledSelectedKeysRef.value = value;\n            if (onUpdateSelectedKeys) {\n                call(onUpdateSelectedKeys, value, option);\n            }\n            if (_onUpdateSelectedKeys) {\n                call(_onUpdateSelectedKeys, value, option);\n            }\n        }\n        // Drag & Drop\n        function doDragEnter(info) {\n            const { onDragenter } = props;\n            if (onDragenter)\n                call(onDragenter, info);\n        }\n        function doDragLeave(info) {\n            const { onDragleave } = props;\n            if (onDragleave)\n                call(onDragleave, info);\n        }\n        function doDragEnd(info) {\n            const { onDragend } = props;\n            if (onDragend)\n                call(onDragend, info);\n        }\n        function doDragStart(info) {\n            const { onDragstart } = props;\n            if (onDragstart)\n                call(onDragstart, info);\n        }\n        function doDragOver(info) {\n            const { onDragover } = props;\n            if (onDragover)\n                call(onDragover, info);\n        }\n        function doDrop(info) {\n            const { onDrop } = props;\n            if (onDrop)\n                call(onDrop, info);\n        }\n        function resetDndState() {\n            resetDragState();\n            resetDropState();\n        }\n        function resetDragState() {\n            draggingNodeRef.value = null;\n        }\n        function resetDropState() {\n            droppingOffsetLevelRef.value = 0;\n            droppingNodeRef.value = null;\n            droppingMouseNodeRef.value = null;\n            droppingPositionRef.value = null;\n            resetDragExpandState();\n        }\n        function resetDragExpandState() {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            nodeKeyToBeExpanded = null;\n        }\n        function handleCheck(node, checked) {\n            // We don't guard for leaf only since we have done it in view layer\n            if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            if (props.internalUnifySelectCheck && !props.multiple) {\n                handleSelect(node);\n                return;\n            }\n            const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                checkStrategy: mergedCheckStrategyRef.value,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n            doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n        }\n        function toggleExpand(node) {\n            if (props.disabled)\n                return;\n            const { key } = node;\n            const { value: mergedExpandedKeys } = mergedExpandedKeysRef;\n            const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);\n            if (~index) {\n                const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n                expandedKeysAfterChange.splice(index, 1);\n                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n            }\n            else {\n                const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n                if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n                    return;\n                }\n                let nextKeys;\n                if (props.accordion) {\n                    const siblingKeySet = new Set(node.siblings.map(({ key }) => key));\n                    nextKeys = mergedExpandedKeys.filter((expandedKey) => {\n                        return !siblingKeySet.has(expandedKey);\n                    });\n                    nextKeys.push(key);\n                }\n                else {\n                    nextKeys = mergedExpandedKeys.concat(key);\n                }\n                doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n            }\n        }\n        function handleSwitcherClick(node) {\n            if (props.disabled || aipRef.value)\n                return;\n            toggleExpand(node);\n        }\n        function handleSelect(node) {\n            if (props.disabled || !props.selectable) {\n                return;\n            }\n            pendingNodeKeyRef.value = node.key;\n            if (props.internalUnifySelectCheck) {\n                const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;\n                if (props.multiple) {\n                    handleCheck(node, !(checkedKeys.includes(node.key) ||\n                        indeterminateKeys.includes(node.key)));\n                }\n                else {\n                    doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n            if (props.multiple) {\n                const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n                const index = selectedKeys.findIndex((key) => key === node.key);\n                if (~index) {\n                    if (props.cancelable) {\n                        selectedKeys.splice(index, 1);\n                    }\n                }\n                else if (!~index) {\n                    selectedKeys.push(node.key);\n                }\n                doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n            }\n            else {\n                const selectedKeys = mergedSelectedKeysRef.value;\n                if (selectedKeys.includes(node.key)) {\n                    if (props.cancelable) {\n                        doUpdateSelectedKeys([], []);\n                    }\n                }\n                else {\n                    doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n        }\n        function expandDragEnterNode(node) {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            // Don't expand leaf node.\n            if (node.isLeaf)\n                return;\n            nodeKeyToBeExpanded = node.key;\n            const expand = () => {\n                if (nodeKeyToBeExpanded !== node.key)\n                    return;\n                const { value: droppingMouseNode } = droppingMouseNodeRef;\n                if (droppingMouseNode &&\n                    droppingMouseNode.key === node.key &&\n                    !mergedExpandedKeysRef.value.includes(node.key)) {\n                    const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n                    doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n                }\n                expandTimerId = null;\n                nodeKeyToBeExpanded = null;\n            };\n            if (!node.shallowLoaded) {\n                expandTimerId = window.setTimeout(() => {\n                    void triggerLoading(node).then(() => {\n                        expand();\n                    });\n                }, 1000);\n            }\n            else {\n                expandTimerId = window.setTimeout(() => {\n                    expand();\n                }, 1000);\n            }\n        }\n        // Dnd\n        function handleDragEnter({ event, node }) {\n            // node should be a tmNode\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            handleDragOver({ event, node }, false);\n            doDragEnter({ event, node: node.rawNode });\n        }\n        function handleDragLeave({ event, node }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragLeave({ event, node: node.rawNode });\n        }\n        function handleDragLeaveTree(e) {\n            if (e.target !== e.currentTarget)\n                return;\n            resetDropState();\n        }\n        // Dragend is ok, we don't need to add global listener to reset drag status\n        function handleDragEnd({ event, node }) {\n            resetDndState();\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragEnd({ event, node: node.rawNode });\n        }\n        function handleDragStart({ event, node }) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            // Most of time, the image will block user's view\n            emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n            dragStartX = event.clientX;\n            draggingNodeRef.value = node;\n            doDragStart({ event, node: node.rawNode });\n        }\n        function handleDragOver({ event, node }, emit = true) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            if (!draggingNode)\n                return;\n            const { allowDrop, indent } = props;\n            if (emit)\n                doDragOver({ event, node: node.rawNode });\n            // Update dropping node\n            const el = event.currentTarget;\n            const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();\n            const eventOffsetY = event.clientY - elClientTop;\n            let mousePosition;\n            const allowDropInside = allowDrop({\n                node: node.rawNode,\n                dropPosition: 'inside',\n                phase: 'drag'\n            });\n            if (allowDropInside) {\n                if (eventOffsetY <= 8) {\n                    mousePosition = 'before';\n                }\n                else if (eventOffsetY >= elOffsetHeight - 8) {\n                    mousePosition = 'after';\n                }\n                else {\n                    mousePosition = 'inside';\n                }\n            }\n            else {\n                if (eventOffsetY <= elOffsetHeight / 2) {\n                    mousePosition = 'before';\n                }\n                else {\n                    mousePosition = 'after';\n                }\n            }\n            const { value: getFindex } = getFIndexRef;\n            /** determine the drop position and drop node */\n            /** the dropping node needn't to be the mouse hovering node! */\n            /**\n             * if there is something i've learned from implementing a complex\n             * drag & drop. that is never write unit test before you really figure\n             * out what behavior is exactly you want.\n             */\n            let finalDropNode;\n            let finalDropPosition;\n            const hoverNodeFIndex = getFindex(node.key);\n            if (hoverNodeFIndex === null) {\n                resetDropState();\n                return;\n            }\n            let mouseAtExpandedNonLeafNode = false;\n            if (mousePosition === 'inside') {\n                finalDropNode = node;\n                finalDropPosition = 'inside';\n            }\n            else {\n                if (mousePosition === 'before') {\n                    if (node.isFirstChild) {\n                        finalDropNode = node;\n                        finalDropPosition = 'before';\n                    }\n                    else {\n                        finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n                        finalDropPosition = 'after';\n                    }\n                }\n                else {\n                    finalDropNode = node;\n                    finalDropPosition = 'after';\n                }\n            }\n            // If the node is non-leaf and it is expanded, we don't allow it to\n            // drop after it and change it to drop before its next view sibling\n            if (!finalDropNode.isLeaf &&\n                mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n                mouseAtExpandedNonLeafNode = true;\n                if (finalDropPosition === 'after') {\n                    finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n                    if (!finalDropNode) {\n                        // maybe there is no next view sibling when non-leaf node has no\n                        // children and it is the last node in the tree\n                        finalDropNode = node;\n                        finalDropPosition = 'inside';\n                    }\n                    else {\n                        finalDropPosition = 'before';\n                    }\n                }\n            }\n            const droppingMouseNode = finalDropNode;\n            droppingMouseNodeRef.value = droppingMouseNode;\n            // This is a speacial case, user is dragging a last child itself, so we\n            // only view it as they are trying to drop after it.\n            // There are some relevant codes in bailout 1's child branch.\n            // Also, the expand bailout should have a high priority. If it's non-leaf\n            // node and expanded, keep its origin drop position\n            if (!mouseAtExpandedNonLeafNode &&\n                draggingNode.isLastChild &&\n                draggingNode.key === finalDropNode.key) {\n                finalDropPosition = 'after';\n            }\n            if (finalDropPosition === 'after') {\n                let offset = dragStartX - event.clientX; // drag left => > 0\n                let offsetLevel = 0;\n                while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n                    finalDropNode.parent !== null &&\n                    finalDropNode.isLastChild &&\n                    offsetLevel < 1) {\n                    offset -= indent;\n                    offsetLevel += 1;\n                    finalDropNode = finalDropNode.parent;\n                }\n                droppingOffsetLevelRef.value = offsetLevel;\n            }\n            else {\n                droppingOffsetLevelRef.value = 0;\n            }\n            // Bailout 1\n            // Drag self into self\n            // Drag it into direct parent\n            if (draggingNode.contains(finalDropNode) ||\n                (finalDropPosition === 'inside' &&\n                    ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key)) {\n                if (draggingNode.key === droppingMouseNode.key &&\n                    draggingNode.key === finalDropNode.key) {\n                    // This is special case that we want ui to show a mark to guide user\n                    // to start dragging. Nor they will think nothing happens.\n                    // However this is an invalid drop, we need to guard it inside\n                    // handleDrop\n                }\n                else {\n                    resetDropState();\n                    return;\n                }\n            }\n            // Bailout 3\n            if (!allowDrop({\n                node: finalDropNode.rawNode,\n                dropPosition: finalDropPosition,\n                phase: 'drag'\n            })) {\n                resetDropState();\n                return;\n            }\n            if (draggingNode.key === finalDropNode.key) {\n                // don't expand when drag on itself\n                resetDragExpandState();\n            }\n            else {\n                if (nodeKeyToBeExpanded !== finalDropNode.key) {\n                    if (finalDropPosition === 'inside') {\n                        if (props.expandOnDragenter) {\n                            expandDragEnterNode(finalDropNode);\n                            // Bailout 4\n                            // not try to loading\n                            if (!finalDropNode.shallowLoaded &&\n                                nodeKeyToBeExpanded !== finalDropNode.key) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                        else {\n                            // Bailout 5\n                            // never expands on drag\n                            if (!finalDropNode.shallowLoaded) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                    }\n                    else {\n                        resetDragExpandState();\n                    }\n                }\n                else {\n                    if (finalDropPosition !== 'inside') {\n                        resetDragExpandState();\n                    }\n                }\n            }\n            droppingPositionRef.value = finalDropPosition;\n            droppingNodeRef.value = finalDropNode;\n        }\n        function handleDrop({ event, node, dropPosition }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            const { value: droppingNode } = droppingNodeRef;\n            const { value: droppingPosition } = droppingPositionRef;\n            if (!draggingNode || !droppingNode || !droppingPosition) {\n                return;\n            }\n            // Bailout 1\n            if (!props.allowDrop({\n                node: droppingNode.rawNode,\n                dropPosition: droppingPosition,\n                phase: 'drag'\n            })) {\n                return;\n            }\n            // Bailout 2\n            // This is a special case to guard since we want ui to show the status\n            // but not to emit a event\n            if (draggingNode.key === droppingNode.key) {\n                return;\n            }\n            // Bailout 3\n            // insert before its next node\n            // insert after its prev node\n            if (droppingPosition === 'before') {\n                const nextNode = draggingNode.getNext({ includeDisabled: true });\n                if (nextNode) {\n                    if (nextNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            if (droppingPosition === 'after') {\n                const prevNode = draggingNode.getPrev({ includeDisabled: true });\n                if (prevNode) {\n                    if (prevNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            doDrop({\n                event,\n                node: droppingNode.rawNode,\n                dragNode: draggingNode.rawNode,\n                dropPosition\n            });\n            resetDndState();\n        }\n        function handleScroll() {\n            syncScrollbar();\n        }\n        function handleResize() {\n            syncScrollbar();\n        }\n        function handleFocusout(e) {\n            var _a;\n            if (props.virtualScroll || props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n                    return;\n                }\n                pendingNodeKeyRef.value = null;\n            }\n            else {\n                const { value: selfEl } = selfElRef;\n                if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))\n                    return;\n                pendingNodeKeyRef.value = null;\n            }\n        }\n        watch(pendingNodeKeyRef, (value) => {\n            var _a, _b;\n            if (value === null)\n                return;\n            if (props.virtualScroll) {\n                (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });\n            }\n            else if (props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if (scrollbarInst === null)\n                    return;\n                const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n                if (!targetEl)\n                    return;\n                scrollbarInst.scrollTo({\n                    el: targetEl\n                });\n            }\n        });\n        provide(treeInjectionKey, {\n            loadingKeysRef,\n            highlightKeySetRef: mergedHighlightKeySetRef,\n            displayedCheckedKeysRef,\n            displayedIndeterminateKeysRef,\n            mergedSelectedKeysRef,\n            mergedExpandedKeysRef,\n            mergedThemeRef: themeRef,\n            mergedCheckStrategyRef,\n            nodePropsRef: toRef(props, 'nodeProps'),\n            disabledRef: toRef(props, 'disabled'),\n            checkableRef: toRef(props, 'checkable'),\n            selectableRef: toRef(props, 'selectable'),\n            expandOnClickRef: toRef(props, 'expandOnClick'),\n            onLoadRef: toRef(props, 'onLoad'),\n            draggableRef: toRef(props, 'draggable'),\n            blockLineRef: toRef(props, 'blockLine'),\n            indentRef: toRef(props, 'indent'),\n            cascadeRef: toRef(props, 'cascade'),\n            checkOnClickRef: toRef(props, 'checkOnClick'),\n            checkboxPlacementRef: props.checkboxPlacement,\n            droppingMouseNodeRef,\n            droppingNodeParentRef,\n            draggingNodeRef,\n            droppingPositionRef,\n            droppingOffsetLevelRef,\n            fNodesRef,\n            pendingNodeKeyRef,\n            disabledFieldRef: toRef(props, 'disabledField'),\n            internalScrollableRef: toRef(props, 'internalScrollable'),\n            internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n            internalTreeSelect: props.internalTreeSelect,\n            renderLabelRef: toRef(props, 'renderLabel'),\n            renderPrefixRef: toRef(props, 'renderPrefix'),\n            renderSuffixRef: toRef(props, 'renderSuffix'),\n            renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n            labelFieldRef: toRef(props, 'labelField'),\n            multipleRef: toRef(props, 'multiple'),\n            handleSwitcherClick,\n            handleDragEnd,\n            handleDragEnter,\n            handleDragLeave,\n            handleDragStart,\n            handleDrop,\n            handleDragOver,\n            handleSelect,\n            handleCheck\n        });\n        function scrollTo(options) {\n            var _a;\n            (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n        }\n        const exposedMethods = {\n            handleKeydown,\n            scrollTo\n        };\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { fontSize, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor } } = themeRef.value;\n            return {\n                '--n-arrow-color': arrowColor,\n                '--n-loading-color': loadingColor,\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-font-size': fontSize,\n                '--n-node-border-radius': nodeBorderRadius,\n                '--n-node-color-active': nodeColorActive,\n                '--n-node-color-hover': nodeColorHover,\n                '--n-node-color-pressed': nodeColorPressed,\n                '--n-node-text-color': nodeTextColor,\n                '--n-node-text-color-disabled': nodeTextColorDisabled,\n                '--n-drop-mark-color': dropMarkColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tree', undefined, cssVarsRef, props)\n            : undefined;\n        return {\n            mergedClsPrefix: mergedClsPrefixRef,\n            mergedTheme: themeRef,\n            rtlEnabled: rtlEnabledRef,\n            fNodes: mergedFNodesRef,\n            aip: aipRef,\n            selfElRef,\n            virtualListInstRef,\n            scrollbarInstRef,\n            handleFocusout,\n            handleDragLeaveTree,\n            handleScroll,\n            getScrollContainer,\n            getScrollContent,\n            handleAfterEnter,\n            handleResize,\n            handleKeydown: exposedMethods.handleKeydown,\n            scrollTo: exposedMethods.scrollTo,\n            cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n        };\n    },\n    render() {\n        var _a;\n        const { fNodes, internalRenderEmpty } = this;\n        if (!fNodes.length && internalRenderEmpty) {\n            return internalRenderEmpty();\n        }\n        const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeydown, rtlEnabled, handleFocusout } = this;\n        const mergedFocusable = internalFocusable && !disabled;\n        const tabindex = mergedFocusable ? '0' : undefined;\n        const treeClass = [\n            `${mergedClsPrefix}-tree`,\n            rtlEnabled && `${mergedClsPrefix}-tree--rtl`,\n            checkable && `${mergedClsPrefix}-tree--checkable`,\n            (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,\n            blockLine && `${mergedClsPrefix}-tree--block-line`\n        ];\n        const createNode = (tmNode) => {\n            return '__motion' in tmNode ? (h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter })) : (h(NTreeNode, { key: tmNode.key, tmNode: tmNode, clsPrefix: mergedClsPrefix }));\n        };\n        if (this.virtualScroll) {\n            const { mergedTheme, internalScrollablePadding } = this;\n            const padding = getPadding(internalScrollablePadding || '0');\n            return (h(NxScrollbar, { ref: \"scrollbarInstRef\", onDragleave: draggable ? this.handleDragLeaveTree : undefined, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined }, {\n                default: () => {\n                    var _a;\n                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n                    return (h(VVirtualList, { ref: \"virtualListInstRef\", items: this.fNodes, itemSize: ITEM_SIZE, ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [\n                            this.cssVars,\n                            {\n                                paddingLeft: padding.left,\n                                paddingRight: padding.right\n                            }\n                        ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {\n                        default: ({ item }) => createNode(item)\n                    }));\n                }\n            }));\n        }\n        const { internalScrollable } = this;\n        treeClass.push(this.themeClass);\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (internalScrollable) {\n            return (h(NxScrollbar, { class: treeClass, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }, {\n                default: () => (h(\"div\", { onDragleave: draggable ? this.handleDragLeaveTree : undefined, ref: \"selfElRef\" }, this.fNodes.map(createNode)))\n            }));\n        }\n        else {\n            return (h(\"div\", { class: treeClass, tabindex: tabindex, ref: \"selfElRef\", style: this.cssVars, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, onDragleave: draggable ? this.handleDragLeaveTree : undefined }, !fNodes.length\n                ? resolveSlot(this.$slots.empty, () => [\n                    h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })\n                ])\n                : fNodes.map(createNode)));\n        }\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}