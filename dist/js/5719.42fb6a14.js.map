{"version":3,"file":"js/5719.42fb6a14.js","mappings":"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","sources":["webpack://shc_community_manager_system/./node_modules/naive-ui/es/_utils/vue/create-ref-setter.js","webpack://shc_community_manager_system/./node_modules/naive-ui/es/_utils/vue/get-slot.js","webpack://shc_community_manager_system/./node_modules/naive-ui/es/icon/src/styles/index.cssr.js","webpack://shc_community_manager_system/./node_modules/naive-ui/es/icon/src/Icon.js","webpack://shc_community_manager_system/./node_modules/seemly/es/dom/happens-in.js","webpack://shc_community_manager_system/./node_modules/treemate/es/check.js","webpack://shc_community_manager_system/./node_modules/treemate/es/path.js","webpack://shc_community_manager_system/./node_modules/treemate/es/move.js","webpack://shc_community_manager_system/./node_modules/treemate/es/contains.js","webpack://shc_community_manager_system/./node_modules/treemate/es/create.js","webpack://shc_community_manager_system/./node_modules/treemate/es/flatten.js","webpack://shc_community_manager_system/./node_modules/treemate/es/utils.js"],"sourcesContent":["export function createRefSetter(ref) {\n    return (inst) => {\n        if (inst) {\n            ref.value = inst.$el;\n        }\n        else {\n            ref.value = null;\n        }\n    };\n}\n","export function getSlot(instance, slotName = 'default', fallback = []) {\n    const slots = instance.$slots;\n    const slot = slots[slotName];\n    if (slot === undefined)\n        return fallback;\n    return slot();\n}\n","import { c, cB, cM } from '../../../_utils/cssr'; // vars:\n// --n-bezier\n// --n-color\n// --n-opacity\n\nexport default cB('icon', `\n height: 1em;\n width: 1em;\n line-height: 1em;\n text-align: center;\n display: inline-block;\n position: relative;\n fill: currentColor;\n transform: translateZ(0);\n`, [cM('color-transition', {\n  transition: 'color .3s var(--n-bezier)'\n}), cM('depth', {\n  color: 'var(--n-color)'\n}, [c('svg', {\n  opacity: 'var(--n-opacity)',\n  transition: 'opacity .3s var(--n-bezier)'\n})]), c('svg', {\n  height: '1em',\n  width: '1em'\n})]);","import { computed, defineComponent, h, mergeProps } from 'vue';\nimport { useThemeClass, useConfig, useTheme } from '../../_mixins';\nimport { formatLength, warn } from '../../_utils';\nimport { iconLight } from '../styles';\nimport style from './styles/index.cssr';\nexport const iconProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number], size: [Number, String], color: String, component: Object });\nexport const NIcon = defineComponent({\n    _n_icon__: true,\n    name: 'Icon',\n    inheritAttrs: false,\n    props: iconProps,\n    setup(props) {\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        const themeRef = useTheme('Icon', '-icon', style, iconLight, props, mergedClsPrefixRef);\n        const cssVarsRef = computed(() => {\n            const { depth } = props;\n            const { common: { cubicBezierEaseInOut }, self } = themeRef.value;\n            if (depth !== undefined) {\n                const { color, [`opacity${depth}Depth`]: opacity } = self;\n                return {\n                    '--n-bezier': cubicBezierEaseInOut,\n                    '--n-color': color,\n                    '--n-opacity': opacity\n                };\n            }\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-color': '',\n                '--n-opacity': ''\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('icon', computed(() => `${props.depth || 'd'}`), cssVarsRef, props)\n            : undefined;\n        return {\n            mergedClsPrefix: mergedClsPrefixRef,\n            mergedStyle: computed(() => {\n                const { size, color } = props;\n                return {\n                    fontSize: formatLength(size),\n                    color\n                };\n            }),\n            cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n        };\n    },\n    render() {\n        var _a;\n        const { $parent, depth, mergedClsPrefix, component, onRender, themeClass } = this;\n        if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {\n            warn('icon', \"don't wrap `n-icon` inside `n-icon`\");\n        }\n        onRender === null || onRender === void 0 ? void 0 : onRender();\n        return h('i', mergeProps(this.$attrs, {\n            role: 'img',\n            class: [\n                `${mergedClsPrefix}-icon`,\n                themeClass,\n                {\n                    [`${mergedClsPrefix}-icon--depth`]: depth,\n                    [`${mergedClsPrefix}-icon--color-transition`]: depth !== undefined\n                }\n            ],\n            style: [this.cssVars, this.mergedStyle]\n        }), component ? h(component) : this.$slots);\n    }\n});\n","export function happensIn(e, dataSetPropName) {\n    let { target } = e;\n    while (target) {\n        if (target.dataset) {\n            if (target.dataset[dataSetPropName] !== undefined)\n                return true;\n        }\n        target = target.parentElement;\n    }\n    return false;\n}\n","import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n","export function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {\n    var _a;\n    const treeNodeMap = treeMate.treeNodeMap;\n    let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;\n    const mergedPath = {\n        keyPath: [],\n        treeNodePath: [],\n        treeNode: treeNode\n    };\n    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {\n        mergedPath.treeNode = null;\n        return mergedPath;\n    }\n    while (treeNode) {\n        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {\n            mergedPath.treeNodePath.push(treeNode);\n        }\n        treeNode = treeNode.parent;\n    }\n    mergedPath.treeNodePath.reverse();\n    if (!includeSelf)\n        mergedPath.treeNodePath.pop();\n    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode) => treeNode.key);\n    return mergedPath;\n}\n","export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n","export function contains(parent, child) {\n    const parentKey = parent.key;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (child) {\n        if (child.key === parentKey)\n            return true;\n        child = child.parent;\n    }\n    return false;\n}\n","import { getCheckedKeys } from './check';\nimport { toArray, isDisabled, isLeaf, isGroup, isNodeInvalid, unwrapCheckedKeys, isShallowLoaded, unwrapIndeterminateKeys, getNonLeafKeys, isIgnored, defaultGetChildren, defaultGetKey } from './utils';\nimport { getPath } from './path';\nimport { moveMethods, getFirstAvailableNode } from './move';\nimport { flatten } from './flatten';\nimport { contains } from './contains';\nfunction createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {\n    const treeNodes = [];\n    rawNodes.forEach((rawNode, index) => {\n        var _a;\n        if (process.env.NODE_ENV !== 'production' &&\n            isNodeInvalid(rawNode, getChildren)) {\n            console.error('[treemate]: node', rawNode, 'is invalid');\n        }\n        const treeNode = Object.create(nodeProto);\n        treeNode.rawNode = rawNode;\n        treeNode.siblings = treeNodes;\n        treeNode.level = level;\n        treeNode.index = index;\n        treeNode.isFirstChild = index === 0;\n        treeNode.isLastChild = index + 1 === rawNodes.length;\n        treeNode.parent = parent;\n        if (!treeNode.ignored) {\n            const rawChildren = getChildren(rawNode);\n            if (Array.isArray(rawChildren)) {\n                treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);\n            }\n        }\n        treeNodes.push(treeNode);\n        treeNodeMap.set(treeNode.key, treeNode);\n        if (!levelTreeNodeMap.has(level))\n            levelTreeNodeMap.set(level, []);\n        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);\n    });\n    return treeNodes;\n}\nexport function createTreeMate(rawNodes, options = {}) {\n    var _a;\n    const treeNodeMap = new Map();\n    const levelTreeNodeMap = new Map();\n    const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;\n    const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;\n    const getChildren = options.ignoreEmptyChildren\n        ? (node) => {\n            const children = _getChildren(node);\n            if (Array.isArray(children)) {\n                if (!children.length)\n                    return null;\n                return children;\n            }\n            return children;\n        }\n        : _getChildren;\n    const nodeProto = Object.assign({\n        get key() {\n            // do not pass parent or related things to it\n            // the key need to be specified explicitly\n            return getKey(this.rawNode);\n        },\n        get disabled() {\n            return getDisabled(this.rawNode);\n        },\n        get isGroup() {\n            return getIsGroup(this.rawNode);\n        },\n        get isLeaf() {\n            return isLeaf(this.rawNode, getChildren);\n        },\n        get shallowLoaded() {\n            return isShallowLoaded(this.rawNode, getChildren);\n        },\n        get ignored() {\n            return getIgnored(this.rawNode);\n        },\n        contains(node) {\n            return contains(this, node);\n        }\n    }, moveMethods);\n    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);\n    function getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function _getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function getPrev(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getPrev(options);\n    }\n    function getNext(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getNext(options);\n    }\n    function getParent(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getParent();\n    }\n    function getChild(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getChild();\n    }\n    const treemate = {\n        treeNodes,\n        treeNodeMap,\n        levelTreeNodeMap,\n        maxLevel: Math.max(...levelTreeNodeMap.keys()),\n        getChildren,\n        getFlattenedNodes(expandedKeys) {\n            return flatten(treeNodes, expandedKeys);\n        },\n        getNode,\n        getPrev,\n        getNext,\n        getParent,\n        getChild,\n        getFirstAvailableNode() {\n            return getFirstAvailableNode(treeNodes);\n        },\n        getPath(key, options = {}) {\n            return getPath(key, options, treemate);\n        },\n        getCheckedKeys(checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        check(keysToCheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToCheck: keysToCheck === undefined || keysToCheck === null\n                    ? []\n                    : toArray(keysToCheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        uncheck(keysToUncheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToUncheck: keysToUncheck === null || keysToUncheck === undefined\n                    ? []\n                    : toArray(keysToUncheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        getNonLeafKeys(options = {}) {\n            return getNonLeafKeys(treeNodes, options);\n        }\n    };\n    return treemate;\n}\n","export function flatten(treeNodes, expandedKeys) {\n    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;\n    const flattenedNodes = [];\n    function traverse(treeNodes) {\n        treeNodes.forEach((treeNode) => {\n            flattenedNodes.push(treeNode);\n            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)\n                return;\n            if (treeNode.isGroup) {\n                // group node shouldn't be expanded\n                traverse(treeNode.children);\n            }\n            else if (\n            // normal non-leaf node\n            expandedKeySet === undefined ||\n                expandedKeySet.has(treeNode.key)) {\n                traverse(treeNode.children);\n            }\n        });\n    }\n    traverse(treeNodes);\n    return flattenedNodes;\n}\n","export function toArray(arg) {\n    if (Array.isArray(arg))\n        return arg;\n    return [arg];\n}\n// Do not use enum for lint plugin has error\nexport const TRAVERSE_COMMAND = {\n    STOP: 'STOP'\n};\nexport function traverseWithCb(treeNode, callback) {\n    const command = callback(treeNode);\n    if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {\n        treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));\n    }\n}\nexport function getNonLeafKeys(treeNodes, options = {}) {\n    const { preserveGroup = false } = options;\n    const keys = [];\n    const cb = preserveGroup\n        ? (node) => {\n            if (!node.isLeaf) {\n                keys.push(node.key);\n                traverse(node.children);\n            }\n        }\n        : (node) => {\n            if (!node.isLeaf) {\n                if (!node.isGroup)\n                    keys.push(node.key);\n                traverse(node.children);\n            }\n        };\n    function traverse(nodes) {\n        nodes.forEach(cb);\n    }\n    traverse(treeNodes);\n    return keys;\n}\nexport function isLeaf(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf !== undefined)\n        return isLeaf;\n    else if (!getChildren(rawNode))\n        return true;\n    return false;\n}\nexport function defaultGetChildren(node) {\n    return node.children;\n}\nexport function defaultGetKey(node) {\n    return node.key;\n}\nexport function isIgnored() {\n    return false;\n}\nexport function isShallowLoaded(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf === false && !Array.isArray(getChildren(rawNode)))\n        return false;\n    return true;\n}\nexport function isDisabled(rawNode) {\n    return rawNode.disabled === true;\n}\nexport function isExpilicitlyNotLoaded(rawNode, getChildren) {\n    return (rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode)));\n}\nexport function isNodeInvalid(rawNode, getChildren) {\n    if (rawNode.isLeaf === true) {\n        const children = getChildren(rawNode);\n        if (Array.isArray(children) && children.length > 0)\n            return true;\n    }\n    return false;\n}\nexport function unwrapCheckedKeys(result) {\n    var _a;\n    if (result === undefined || result === null)\n        return [];\n    if (Array.isArray(result))\n        return result;\n    return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function unwrapIndeterminateKeys(result) {\n    var _a;\n    if (result === undefined || result === null || Array.isArray(result)) {\n        return [];\n    }\n    return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function merge(originalKeys, keysToAdd) {\n    const set = new Set(originalKeys);\n    keysToAdd.forEach((key) => {\n        if (!set.has(key)) {\n            set.add(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function minus(originalKeys, keysToRemove) {\n    const set = new Set(originalKeys);\n    keysToRemove.forEach((key) => {\n        if (set.has(key)) {\n            set.delete(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function isGroup(rawNode) {\n    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';\n}\nexport function createIndexGetter(treeNodes) {\n    const map = new Map();\n    treeNodes.forEach((treeNode, i) => {\n        map.set(treeNode.key, i);\n    });\n    return (key) => { var _a; return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null; };\n}\n"],"names":["createRefSetter","ref","inst","value","$el","getSlot","instance","slotName","fallback","slots","$slots","slot","undefined","cB","cM","transition","color","c","opacity","height","width","iconProps","Object","assign","useTheme","depth","String","Number","size","component","NIcon","defineComponent","_n_icon__","name","inheritAttrs","props","setup","mergedClsPrefixRef","inlineThemeDisabled","useConfig","themeRef","style","iconLight","cssVarsRef","computed","common","cubicBezierEaseInOut","self","themeClassHandle","useThemeClass","mergedClsPrefix","mergedStyle","fontSize","formatLength","cssVars","themeClass","onRender","render","_a","$parent","this","$options","warn","h","mergeProps","$attrs","role","class","happensIn","e","dataSetPropName","target","dataset","parentElement","SubtreeNotLoadedError","Error","constructor","super","message","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","concat","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","Set","forEach","uncheckedKey","uncheckedTreeNode","treeNodeMap","get","nodeCursor","parent","disabled","has","key","add","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","keysToRemove","push","delete","getCheckedKeys","options","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","merge","Array","from","minus","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","Math","max","apply","keys","level","levelIsZero","levelTreeNodes","levelTreeNode","isLeaf","levelTreeNodeKey","shallowLoaded","children","v","fullyChecked","partialChecked","allDisabled","childNode","childKey","isUnchecking","getChildren","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","traverseWithCb","treeNode","TRAVERSE_COMMAND","isExpilicitlyNotLoaded","rawNode","getPath","includeGroup","includeSelf","mergedPath","keyPath","treeNodePath","ignored","isGroup","reverse","pop","map","getFirstAvailableNode","nodes","length","node","getNext","rawGetNext","loop","sibs","siblings","l","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","meet","endNode","traverse","child","getChild","nextNode","rawGetParent","start","end","delta","i","childInGroup","moveMethods","getParent","getPrev","contains","parentKey","createTreeNodes","rawNodes","nodeProto","treeNodes","create","isFirstChild","isLastChild","rawChildren","isArray","set","createTreeMate","Map","getDisabled","isDisabled","getIgnored","isIgnored","getIsGroup","getKey","defaultGetKey","_getChildren","defaultGetChildren","ignoreEmptyChildren","isShallowLoaded","getNode","tmNode","_getNode","treemate","getFlattenedNodes","expandedKeys","flatten","unwrapCheckedKeys","unwrapIndeterminateKeys","check","toArray","uncheck","getNonLeafKeys","expandedKeySet","flattenedNodes","arg","STOP","callback","command","preserveGroup","cb","result","originalKeys","keysToAdd","type","createIndexGetter"],"sourceRoot":""}